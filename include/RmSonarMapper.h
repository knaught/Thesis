// RmSonarMapper.h

#ifndef RM_SONAR_MAPPER_H
#define RM_SONAR_MAPPER_H

#include <fstream>
#include <vector>
#include "RmActionHandler.h"
#include "RmPioneerController.h"
#include "RmUtility.h"
#include "RmSonarMap.h"
#include "RmSettings.h"
#include "RmServer.h"

/**
 * Processes sonar range readings as they are received from a Pioneer robot or simulator,
 * mapping them to a RmSonarMap and recording them to file.
 *
 * Installs and initializes a connection to a Pioneer robot, or Pioneer simulator if a robot 
 * connection is unavailable, via the Aria robot controller API; serves as the dispatcher of all 
 * mapping activity in response to real or simulated robot actions, and logs
 * robot pose and sonar range reading data to the log file provided at construction.
 */

class RmSonarMapper : public RmActionHandler
{
public:

	/** Identifies the type of trigger that caused an update. */
	enum UpdateType 
	{ 
		/** No update was triggered */
		None, 

		/** An update was triggered by a max distance of travel being reached */

		Distance, 

		/** An update was triggered by a max degree of turn being reached */
		Turn 
	};


	/**
	 * Initializes the object, setting it up as a handler for the generic
	 * ActionHook event listener, creating a sonar map and sonar data output file.
	 * @param s specifies RmSettings::CellSize
	 * @param sonarOut the file to which robot pose and sonar range reading data is written
	 * @param m the map for which RmSonarMap::update() will be called
	 * @param rs the server that will be serving map viewer strings (generated by this mapper)
	 */
	RmSonarMapper( const RmSettings &s, std::ofstream &sonarOut, RmSonarMap *m, RmServer *rs = NULL )
		: m_settings(s), m_sonarOut(&sonarOut), m_bayesianGrid(m), m_remoteViewServer(rs) {}


	/**
	 * Initializes the object, setting it up as a handler for sonar data directly fed via
	 * mapReading().
	 * Use this in place of the full constructor as a means for processing static file data.
	 */
	RmSonarMapper( const RmSettings &s, RmSonarMap *m )
		: m_settings(s), m_sonarOut(NULL), m_bayesianGrid(m), m_remoteViewServer(NULL) {}

	
	/**
	 * Designed to be called as part of the real-time ActionHook::fire() event sequence. 
	 * Forwards robot pose and range reading data on to handleReading().
	 * @param robot the ArRobot passed to RmActionHook::fire()
	 */
	void handleAction( ArRobot *robot );


	/**
	 * Processing one range reading per call,
	 * updates the sonar map once per distance/degree interval (as determined by 
	 * RmSettings::MaxCollectionDistance and RmSettings::MaxCollectionDegrees) with
	 * a single sonar sweep that represents all readings collected within the interval.
	 * Each call steps through this sweep one range reading at a time.
	 * @param reading the complete sonar sweep; if null, resets the internal state such that
	 * the <i>next</i> call will process the first range reading, and returns an empty string
	 * @param sonarNumber the specific sonar within the sweep to be mapped
	 */
	std::string mapReading( RmUtility::SonarReading *reading, const int sonarNumber );


	/**
	 * Processing an entire sonar sweep per call,
	 * updates the sonar map once per distance/degree interval (as determined by 
	 * RmSettings::MaxCollectionDistance and RmSettings::MaxCollectionDegrees) with
	 * a single sonar reading that represents all readings collected within the interval.
	 * Records pose and sonar data (if an output file was provided during construction).
	 * @return true if an actual update to the sonar map was made
	 */
	bool mapReadings( RmUtility::SonarReading &readings );

	
	/**
	 * Assigns the server that will be serving map viewer strings (generated by this mapper).
	 * As map update strings are received from the RmSonarMap, this server is used to
	 * forward them on to its client.
	 */
	void setRemoteViewServer( RmServer *rs ) { m_remoteViewServer = rs; }


	/**
	 * Returns true if an update to the sonar map should be made.
	 * Determination is based upon the distance traveled and degree of turn made since the last 
	 * update.
	 * @param pose the last reported robot pose
	 */
	inline UpdateType updateTriggered( const RmUtility::Pose &pose );


	/**
	 * Sets the internal state such that processing of in-progress sonar readings (via mapReading())
	 * is terminated and reset for a new reading.
	 */
	void reset() { mapReading( NULL, 0 ); }


protected:

	/**
	 * Returns a single SonarReading that represents the given collection of readings.
	 * This reading is compiled by taking the shortest of all sonar readings for each sonar.
	 * @return null if the collection is empty, representative reading otherwise
	 */
	RmUtility::SonarReading *readingFrom( std::vector<RmUtility::SonarReading> &collection );


	/**
	 * Updates the sonar map using the given collection of sonar readings.
	 * At present, takes the last reading in the collection as the representative reading.
	 */
	std::string updateUsing( RmUtility::SonarReading *reading, const int sonarNumber = -1 );

	
	/**
	 * Sends the given data to the sonar data file opened during
	 * construction, formatting as text, with a space separating each value.
	 */
	void saveReadings( const ArPose &pose, const RmUtility::SonarReading &readings );

private:

	const RmSettings &m_settings;

	std::ofstream *m_sonarOut; // the sonar data output file
		// Programming Note: this ofstream cannot be a reference initialized via copy constructor
		// using by-reference parameters as doing so causes illegal memory access upon destruction
	
	RmSonarMap *m_bayesianGrid; // the occupancy grid to which pose and sonar data is sent

	RmServer *m_remoteViewServer; // the server from which log strings are served
};

#endif