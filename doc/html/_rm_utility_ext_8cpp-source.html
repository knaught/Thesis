<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Robot Mapper: src/RmUtilityExt.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">src</a></div>
<h1>RmUtilityExt.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// RmUtilityExt.cpp</span>
00002 
00003 <span class="preprocessor">#include &lt;iostream&gt;</span>
00004 <span class="preprocessor">#include "RmUtilityExt.h"</span>
00005 
00006 
<a name="l00007"></a><a class="code" href="namespace_rm_utility.html#a5">00007</a> std::vector&lt;float&gt; <a class="code" href="namespace_rm_utility.html#a5">RmUtility::gaussKernel</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> length, <span class="keyword">const</span> <span class="keywordtype">float</span> sigma, <span class="keyword">const</span> <span class="keywordtype">float</span> mu )
00008 {
00009         <span class="keyword">const</span> <span class="keywordtype">float</span> fitFactor = 10.0f; <span class="comment">// scales x to generate a "visually pleasing" distribution within</span>
00010                 <span class="comment">// the confines of the vector; that is, one that tapers off nicely versus being cut off</span>
00011                 <span class="comment">// abruptly; can be thought of as a "zoom", where a lower number zooms in, higher zooms out</span>
00012 
00013         std::vector&lt;float&gt; kernel( length );
00014 
00015         <span class="keyword">const</span> <span class="keywordtype">float</span> sigmaSq2 = (sigma * sigma) * 2; <span class="comment">// to speed up calc in loop</span>
00016         <span class="keyword">const</span> <span class="keywordtype">float</span> sigmaSqrt2pi = sigma * sqrt( 2 * RmUtility::Pi ); <span class="comment">// to speed up calc in loop</span>
00017         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; length; ++i ) 
00018         {
00019                 <span class="comment">// shift x in {0..9} to {-5..4} and smooth distribution into vector</span>
00020                 <span class="keyword">const</span> <span class="keywordtype">float</span> x = - ( length / 2 - i ) / (length / fitFactor);
00021 
00022                 <span class="comment">// precalc</span>
00023                 <span class="keyword">const</span> <span class="keywordtype">float</span> xMinusMu = x - mu;
00024 
00025                 <span class="comment">// probability density function for the normal distribution</span>
00026                 kernel[i] = exp( -(xMinusMu * xMinusMu) / (2 * (sigma * sigma)) ) / sigmaSqrt2pi;
00027         }
00028 
00029         <span class="keywordflow">return</span> kernel;
00030 }
00031 
00032 
<a name="l00033"></a><a class="code" href="namespace_rm_utility.html#a6">00033</a> <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> <a class="code" href="namespace_rm_utility.html#a6">RmUtility::gaussGrid</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> w, <span class="keyword">const</span> <span class="keywordtype">int</span> h, <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> origin, 
00034         <span class="keyword">const</span> <span class="keywordtype">float</span> theta, <span class="keyword">const</span> <span class="keywordtype">float</span> sigma, <span class="keyword">const</span> <span class="keywordtype">float</span> yBend, <span class="keyword">const</span> <span class="keywordtype">float</span> xBend )
00035 {
00036         <span class="keywordflow">if</span> ( yBend != 0 &amp;&amp; xBend != 0 ) {
00037                 <span class="keywordflow">throw</span> <a class="code" href="struct_rm_exceptions_1_1_invalid_parameter_exception.html">RmExceptions::InvalidParameterException</a>( <span class="stringliteral">"RmMutableCartesianGrid::gaussGrid()"</span>,
00038                         <span class="stringliteral">"yBend and xBend cannot both be non-zero"</span> );
00039         }
00040 
00041         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gaussG( w, h, origin );
00042         std::vector&lt;float&gt; gaussW( <a class="code" href="namespace_rm_utility.html#a5">gaussKernel</a>( w, sigma ) );
00043         std::vector&lt;float&gt; gaussH( <a class="code" href="namespace_rm_utility.html#a5">gaussKernel</a>( h, sigma ) );
00044 
00045         <span class="keyword">const</span> <span class="keywordtype">int</span> wMid = w / 2;
00046         <span class="keyword">const</span> <span class="keywordtype">int</span> hMid = h / 2;
00047         <span class="keyword">const</span> <span class="keywordtype">float</span> gaussMax = gaussW[wMid] * gaussH[hMid];
00048         <span class="keyword">const</span> <span class="keywordtype">float</span> gaussNorm = 0.9 / gaussMax;
00049         <span class="keyword">const</span> <span class="keywordtype">float</span> yBendFactor = yBend * h;
00050         <span class="keyword">const</span> <span class="keywordtype">float</span> xBendFactor = xBend * w;
00051         <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_bound_box.html">RmUtility::BoundBox</a> bound = gaussG.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>();
00052 
00053         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = bound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; y &gt;= bound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --y ) 
00054         {
00055                 <span class="comment">// Find index into vertical gauss vector</span>
00056                 <span class="keyword">const</span> <span class="keywordtype">int</span> hIndex = hMid - abs(y - origin.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>);
00057 
00058                 <span class="comment">// Shift index into horizontal gauss vector relative to vertical distance from origin</span>
00059                 <span class="comment">// As value of gaussK gets further from max(gaussK),</span>
00060                 <span class="comment">// horizontal gaussG is shifted left (or right) proportionately</span>
00061                 <span class="keyword">const</span> <span class="keywordtype">float</span> xDelta = (gaussH[hMid] - gaussH[hIndex]) * xBendFactor;
00062 
00063                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = bound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; x &lt;= bound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++x ) 
00064                 {
00065                         <span class="comment">// Find index into horizontal gauss vector</span>
00066                         <span class="keyword">const</span> <span class="keywordtype">int</span> wIndex = wMid - abs(x - origin.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>);
00067 
00068                         <span class="comment">// Shift index into vertical gauss vector relative to horizontal distance from origin</span>
00069                         <span class="comment">// As value of gaussK gets further from max(gaussK),</span>
00070                         <span class="comment">// vertical gaussG is shifted down (or up) proportionately</span>
00071                         <span class="keyword">const</span> <span class="keywordtype">float</span> yDelta = (gaussW[wMid] - gaussW[wIndex]) * yBendFactor;
00072 
00073                         <span class="comment">// Convolve vertical and horizontal gaussians, normalized to max</span>
00074                         gaussG[x - xDelta][y - yDelta] = gaussH[hIndex] * gaussW[wIndex] * gaussNorm;
00075                 }
00076         }
00077 
00078         gaussG.<a class="code" href="class_rm_mutable_cartesian_grid.html#a12">rotateBy</a>( theta );
00079         gaussG.<a class="code" href="class_rm_mutable_cartesian_grid.html#a15">trim</a>();
00080 
00081         <span class="keywordflow">return</span> gaussG;
00082 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Apr 3 16:46:54 2005 for Robot Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
