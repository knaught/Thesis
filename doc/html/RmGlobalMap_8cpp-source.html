<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Robot Mapper: src/RmGlobalMap.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">src</a></div>
<h1>RmGlobalMap.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// RmGlobalMap.cpp</span>
00002 
00003 <span class="comment">/* Notes:</span>
00004 <span class="comment"> * On nomenclature.  Variables that have a world (unscaled) or grid (scaled) frame of reference are</span>
00005 <span class="comment"> * prepended with a "w" or "g", respectively.</span>
00006 <span class="comment"> */</span>
00007 
00008 <span class="preprocessor">#pragma warning( disable : 4786 )</span>
00009 <span class="preprocessor"></span>
00010 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00011 <span class="preprocessor">#include &lt;cmath&gt;</span>
00012 <span class="preprocessor">#include &lt;iostream&gt;</span>
00013 <span class="preprocessor">#include &lt;string&gt;</span>
00014 <span class="preprocessor">#include "RmGlobalMap.h"</span>
00015 <span class="keyword">using</span> RmGlobalMap::RegionId;
00016 <span class="preprocessor">#include "RmUtilityExt.h"</span>
00017 <span class="preprocessor">#include "RmExceptions.h"</span>
00018 <span class="keyword">using</span> <span class="keyword">namespace </span>RmExceptions;
00019 <span class="preprocessor">#include "RmUtility.h"</span>
00020 
00021 
00022 <span class="keyword">using</span> <a class="code" href="structRmUtility_1_1BoundBox.html">RmUtility::BoundBox</a>;
00023 <span class="keyword">using</span> <a class="code" href="classRmUtility_1_1Coord.html">RmUtility::Coord</a>;
00024 <span class="keyword">using</span> <a class="code" href="structRmUtility_1_1Pose.html">RmUtility::Pose</a>;
00025 <span class="keyword">using</span> <a class="code" href="structRmUtility_1_1SonarReading.html">RmUtility::SonarReading</a>;
00026 <span class="keyword">using</span> <a class="code" href="structRmUtility_1_1MappedSonarReading.html">RmUtility::MappedSonarReading</a>;
00027 
00028 
<a name="l00029"></a><a class="code" href="classRmGlobalMap.html#a9">00029</a> <a class="code" href="classRmGlobalMap.html#a9">RmGlobalMap::RmGlobalMap</a>( <a class="code" href="structRmSettings.html">RmSettings</a>* s )
00030         : <a class="code" href="classRmBayesCertaintyGrid.html">RmBayesCertaintyGrid</a>( s, <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>() ),
00031           m_settings(s), m_finalized(false), m_currentMap(NULL), m_wDistance(0.0), 
00032           m_regionMap(), m_maxRegionId(0)
00033 {
00034         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *signature_ = <span class="stringliteral">"RmGlobalMap::RmGlobalMap(RmSettings*)"</span>;
00035         <span class="keywordflow">if</span> ( s == NULL ) <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1InvalidParameterException.html">InvalidParameterException</a>( signature_, <span class="stringliteral">"RmSettings may not be null"</span> );
00036 
00037         <span class="comment">// Open localization log file</span>
00038         <span class="keywordflow">if</span> ( s-&gt;<a class="code" href="structRmSettings.html#o7">Localize</a> &amp;&amp; s-&gt;<a class="code" href="structRmSettings.html#o4">GridName</a> != <span class="stringliteral">""</span> ) {
00039                 m_debugLogName = s-&gt;<a class="code" href="structRmSettings.html#o4">GridName</a>;
00040                 m_debugLogName.append( <span class="stringliteral">".log"</span> );
00041                 m_debugLog.open( m_debugLogName.c_str() );
00042                 m_debugLog.setf( std::ios_base::fixed, std::ios_base::floatfield );
00043                 m_debugLog.precision( 4 );
00044         }
00045 }
00046 
00047 
<a name="l00048"></a><a class="code" href="classRmGlobalMap.html#b0">00048</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#b0">RmGlobalMap::addToRegionMap</a>( <a class="code" href="classRmLocalMap.html">RmLocalMap</a> *mt )
00049 {
00050         <span class="comment">// Integrates newly built independent L_t into G</span>
00051 
00052         <span class="comment">// Validate input</span>
00053         assert( mt != NULL );
00054         assert( mt-&gt;<a class="code" href="classRmLocalMap.html#a0">cumDistance</a>() &gt; 0 );
00055         assert( m_maps.size() &gt; 0 );
00056 
00057         <span class="comment">// Init region boundary (rt) to that of the local map at time t (lt)</span>
00058         <span class="comment">// Note: map boundaries are expanded by one on their north and eastern borders so as to</span>
00059         <span class="comment">// compensate for the polygon filling routine which excludes cells along those borders</span>
00060         <a class="code" href="classRmPolygon.html">RmPolygon</a> rt( mt-&gt;<a class="code" href="classRmBayesCertaintyGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#a3">expandBy</a>( 1, 0, 1, 0 ) );
00061 
00062         <span class="comment">// Init history of processed regions to region 0, that is, the non-region</span>
00063         std::set&lt;RegionId&gt; processedRegions;
00064         processedRegions.insert( 0 ); <span class="comment">// non-region has id of 0, which is treated as processed</span>
00065 
00066         <span class="comment">// For each prior local map (mi{i=t-1..0})</span>
00067         std::vector&lt;RmLocalMap*&gt;::reverse_iterator mip = m_maps.rbegin();
00068         <span class="keywordflow">while</span> ( ++mip != m_maps.rend() )
00069         {
00070                 <span class="comment">// If prior local map i (bi) intersects that at time t (bx)</span>
00071                 <span class="keyword">const</span> <a class="code" href="classRmPolygon.html">RmPolygon</a> bi( (*mip)-&gt;bound().expandBy( 1, 0, 1, 0 ) );
00072                 <span class="keyword">const</span> <a class="code" href="classRmPolygon.html">RmPolygon</a> bx( bi.intersectedWith( rt ) );
00073                 <span class="keywordflow">if</span> ( bx.numContours() &gt; 0 ) 
00074                 {
00075                         <span class="comment">// For each cell in global map (G) over intersection (bx)</span>
00076                         std::vector&lt;Coord&gt; fill;
00077                         bx.fillInto( &amp;fill );
00078                         std::vector&lt;Coord&gt;::const_iterator cell;
00079                         <span class="keywordflow">for</span>( cell = fill.begin(); cell != fill.end(); ++cell )
00080                         {
00081                                 <span class="comment">// Get region assigned to that cell</span>
00082                                 <span class="keyword">const</span> <a class="code" href="classRmGlobalMap.html#w0">RegionId</a> regionId = m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( cell-&gt;x, cell-&gt;y );
00083 
00084                                 <span class="comment">// If region not previously processed</span>
00085                                 <span class="keywordflow">if</span> ( processedRegions.count( regionId ) == 0 )
00086                                 {
00087                                         <span class="comment">// Get region's intersection (rx) with map bound intersection (bx)</span>
00088                                         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *rc = m_regions[regionId];
00089                                         <span class="comment">// ***</span>
00090                                         <span class="keyword">const</span> <a class="code" href="classRmPolygon.html">RmPolygon</a> rx( rc-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o0">boundary</a>.<a class="code" href="classRmPolygon.html#a2">intersectedWith</a>( bx ) );
00091                                         <span class="comment">// Subtract region intersection (rx) from bound of map at time t (rt)</span>
00092                                         rt -= rx;
00093 
00094                                         <span class="comment">// Subtract region intersection (rx) from region at current cell (rc)</span>
00095                                         <a class="code" href="classRmPolygon.html">RmPolygon</a> bcx( rc-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o0">boundary</a> - rx );
00096 
00097                                         <span class="comment">// [Remove Rc-&gt;L that no longer intersect]</span>
00098 
00099                                         <span class="comment">// If region at cell (rc) is now empty, delete the region</span>
00100                                         <span class="comment">// Note: must use temp bcx so deleteRegion() has rc-&gt;boundary to work with</span>
00101                                         <span class="keywordflow">if</span> ( bcx.numContours() == 0 ) <a class="code" href="classRmGlobalMap.html#b2">deleteRegion</a>( &amp;rc );
00102                                         <span class="keywordflow">else</span> rc-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o0">boundary</a> = bcx;
00103                                         
00104                                         <span class="comment">// Create new region (rnew) as intersection of cell region + map intersection</span>
00105                                         <span class="comment">// Fill new region (rnew) over global map (G) with Rnew.id</span>
00106                                         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *rnew = <a class="code" href="classRmGlobalMap.html#b7">newRegion</a>( rx );
00107 
00108                                         <span class="comment">// Add map at time i (mi) and t (mt) to new region (rnew)</span>
00109                                         rnew-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.insert( *mip );
00110                                         rnew-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.insert( mt );
00111 
00112                                         <span class="comment">// Add maps from cell region (rc) that intersect new region (rnew)</span>
00113                                         <span class="keywordflow">if</span> ( rc != NULL ) { <span class="comment">// (if not just deleted)</span>
00114                                                 std::set&lt;RmLocalMap*&gt;::const_iterator mcp;                                      
00115                                                 <span class="keywordflow">for</span> ( mcp = rc-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.begin(); mcp != rc-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.end(); ++mcp ) 
00116                                                 {
00117                                                         <span class="comment">// Ignore those already assigned to the region</span>
00118                                                         <span class="keywordflow">if</span> ( *mcp == *mip || *mcp == mt ) <span class="keywordflow">continue</span>;
00119 
00120                                                         <span class="comment">// If intersects the region</span>
00121                                                         <span class="keywordflow">if</span> ( rx.intersectedWith( 
00122                                                                 <a class="code" href="classRmPolygon.html">RmPolygon</a>( (*mcp)-&gt;bound() ) ).numContours() &gt; 0 ) 
00123                                                         {
00124                                                                 rnew-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.insert( *mcp );
00125                                                         }
00126                                                 }
00127                                         }
00128 
00129                                         <span class="comment">// Mark intersecting region as processed (original and new)</span>
00130                                         processedRegions.insert( regionId );
00131                                         processedRegions.insert( rnew-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o1">id</a> );
00132                                 }
00133                         }
00134                 }
00135         }
00136 
00137         
00138         <span class="comment">// If B not empty</span>
00139         <span class="keywordflow">if</span> ( rt.numContours() != 0 )
00140         {
00141                 <span class="comment">// Create new region R_t with boundary Bt</span>
00142                 <span class="comment">// For each G region cell in L_t, replace with R_new.id</span>
00143                 <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *rnew = <a class="code" href="classRmGlobalMap.html#b7">newRegion</a>( rt );
00144 
00145                 <span class="comment">// Add L_t to R_new</span>
00146                 rnew-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.insert( mt );
00147         }
00148 }
00149 
00150 
<a name="l00151"></a><a class="code" href="classRmGlobalMap.html#b1">00151</a> std::string <a class="code" href="classRmGlobalMap.html#b1">RmGlobalMap::clearMapString</a>( <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1BoundBox.html">BoundBox</a> &amp;gBound )<span class="keyword"> const</span>
00152 <span class="keyword"></span>{
00153         <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[(gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a> - gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a> + 1) * (gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a> - gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a> + 1) * 17 + 1];
00154         <span class="keywordtype">char</span> *buffPtr = &amp;buff[0];
00155 
00156         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; gY &gt;= gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; --gY ) {
00157                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; gX &lt;= gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; ++gX ) {
00158                         sprintf( buffPtr, <span class="stringliteral">"%d %d %.4f;"</span>, gX, gY, RmBayesCertaintyGrid::InitVal );
00159                         buffPtr += strlen( buffPtr );
00160                 }
00161         }
00162 
00163         std::string logString( buff );
00164         <span class="keyword">delete</span>[] buff;
00165 
00166         <span class="keywordflow">return</span> logString;
00167 }
00168 
00169 
<a name="l00170"></a><a class="code" href="classRmGlobalMap.html#a2">00170</a> <span class="keywordtype">float</span> <a class="code" href="classRmGlobalMap.html#a2">RmGlobalMap::convolvedValueAt</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )<span class="keyword"> const</span>
00171 <span class="keyword"></span>{
00172         <a class="code" href="classRmGlobalMap.html#w0">RegionId</a> rId; <span class="comment">// region id</span>
00173 
00174         <span class="comment">// If the requested cell is out of bounds are not covered by a region,</span>
00175         <span class="comment">// return the default value</span>
00176         <span class="keywordflow">if</span> ( !<a class="code" href="classRmMutableCartesianGrid.html#a4">inBounds</a>( <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>( x, y ) ) || (rId = m_regionMap[x][y]) == 0 ) {
00177                 <span class="keywordflow">return</span> RmBayesCertaintyGrid::InitVal;
00178         }
00179 
00180         <span class="comment">// Get the region covering the cell</span>
00181         std::map&lt;RegionId,Region*&gt;::const_iterator ri( m_regions.find( rId ) ); <span class="comment">// region iterator</span>
00182         assert( ri != m_regions.end() );
00183         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *r = (*ri).second;
00184 
00185         <span class="comment">// Sum non-empty probabilities for each local map assigned to the region</span>
00186         <span class="keywordtype">float</span> gPr = 0.0f; <span class="comment">// global map prior probability</span>
00187         <span class="keywordtype">int</span> cnt = 0;
00188         std::set&lt;RmLocalMap*&gt;::const_iterator mi; <span class="comment">// map iterator</span>
00189         <span class="keywordflow">for</span> ( mi = r-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.begin(); mi != r-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.end(); ++mi )
00190         {
00191                 <span class="comment">// Convolve values</span>
00192                 <span class="keywordtype">float</span> pr = (*mi)-&gt;valueAt( x, y );
00193                 <span class="keywordflow">if</span> ( pr != RmBayesCertaintyGrid::InitVal ) {
00194                         gPr += pr;
00195                         ++cnt;
00196                 }
00197         }
00198         gPr = cnt == 0 ? RmBayesCertaintyGrid::InitVal : gPr / cnt;
00199 
00200         <span class="keywordflow">return</span> gPr;
00201 }
00202 
00203 
<a name="l00204"></a><a class="code" href="classRmGlobalMap.html#b2">00204</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#b2">RmGlobalMap::deleteRegion</a>( <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> **<span class="keyword">const</span> r )
00205 {
00206         assert( *r != NULL );
00207         assert( (*r)-&gt;id &gt; 0 );
00208 
00209         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *rorig = *r; <span class="comment">// save state so can assert it doesn't change</span>
00210 
00211         <a class="code" href="classRmGlobalMap.html#b3">fillRegionMap</a>( *r, 0 );
00212         m_usedRegionIds.push( (*r)-&gt;id );
00213         m_regions.erase( (*r)-&gt;id );
00214 
00215         assert( rorig == *r ); <span class="comment">// this failed when calling this method from within an iteration</span>
00216                 <span class="comment">// over m_regions in RmGlobalMap::empty() because m_regions.erase() would delete *r first,</span>
00217                 <span class="comment">// and a second attempt below would cause a crash</span>
00218 
00219         <span class="keyword">delete</span> *r;
00220         *r = NULL;
00221 }
00222 
00223 
<a name="l00224"></a><a class="code" href="classRmGlobalMap.html#a3">00224</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#a3">RmGlobalMap::empty</a>()
00225 {
00226         <span class="comment">// Free memory allocated for local maps</span>
00227         std::vector&lt;RmLocalMap*&gt;::const_iterator map;
00228         <span class="keywordflow">for</span> ( map = m_maps.begin(); map != m_maps.end(); ++map ) <span class="keyword">delete</span> *map;
00229         m_maps.clear();
00230 
00231         <span class="comment">// Free memory allocated for regions</span>
00232         std::map&lt;RegionId,Region*&gt;::const_iterator region;
00233         <span class="keywordflow">for</span> ( region = m_regions.begin(); region != m_regions.end(); ++region ) 
00234         {
00235                 <span class="keyword">const</span> <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *r = (*region).second;
00236                 <span class="keyword">delete</span> r;
00237                 r = NULL;
00238         }
00239         m_regions.clear(); <span class="comment">// empty collection of region pointers</span>
00240         m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a2">empty</a>(); <span class="comment">// empty the region grid</span>
00241         <span class="keywordflow">while</span> ( !m_usedRegionIds.empty() ) m_usedRegionIds.pop(); <span class="comment">// empty collection of used region ids</span>
00242         m_maxRegionId = 0; <span class="comment">// reset next region id</span>
00243 
00244         m_wDistance = 0.0;
00245         m_currentMap = NULL;
00246         m_gAccumShift = <a class="code" href="structRmUtility_1_1Pose.html">Pose</a>();
00247         m_finalized = <span class="keyword">false</span>;
00248         m_debugLog.seekp( 0 ); <span class="comment">// in lieu of closing and reopening, which doesn't work in dll mode</span>
00249 
00250         <a class="code" href="classRmMutableCartesianGrid.html#a2">RmMutableCartesianGrid&lt;float&gt;::empty</a>();
00251 }
00252 
00253 
<a name="l00254"></a><a class="code" href="classRmGlobalMap.html#b3">00254</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#b3">RmGlobalMap::fillRegionMap</a>( <span class="keyword">const</span> <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *<span class="keyword">const</span> r, <span class="keyword">const</span> RegionId <span class="keywordtype">id</span> )
00255 {
00256         assert( r != NULL );
00257         assert( <span class="keywordtype">id</span> &lt;= m_maxRegionId );
00258 
00259         std::vector&lt;Coord&gt; fill;
00260         r-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o0">boundary</a>.<a class="code" href="classRmPolygon.html#a1">fillInto</a>( &amp;fill );
00261         std::vector&lt;Coord&gt;::const_iterator cell;
00262         <span class="keywordflow">for</span>( cell = fill.begin(); cell != fill.end(); ++cell )
00263         {
00264                 <span class="comment">// Replace with R_new.id</span>
00265                 m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( cell-&gt;x, cell-&gt;y ) = id;
00266         }
00267 }
00268 
00269 
<a name="l00270"></a><a class="code" href="classRmGlobalMap.html#a4">00270</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#a4">RmGlobalMap::finalize</a>()
00271 {
00272         <span class="keywordflow">if</span> ( m_finalized ) <span class="keywordflow">return</span>;
00273 
00274         <span class="keywordflow">if</span> ( m_currentMap != NULL ) <a class="code" href="classRmGlobalMap.html#b0">addToRegionMap</a>( m_currentMap );
00275         <a class="code" href="classRmGlobalMap.html#a6">integrate</a>();
00276 
00277         m_finalized = <span class="keyword">true</span>;
00278 }
00279 
00280 
<a name="l00281"></a><a class="code" href="classRmGlobalMap.html#b4">00281</a> std::string <a class="code" href="classRmGlobalMap.html#b4">RmGlobalMap::installNewMap</a>( <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a>&amp; wNewReading )
00282 {
00283         <span class="comment">// NOTE:  </span>
00284         <span class="comment">// In this context, the "current" map is the map just built in its entirety but not yet</span>
00285         <span class="comment">// convolved with the global map; the "new" map isn't created until after this current</span>
00286         <span class="comment">// map has been relocalized and convolved, and a new map pose localization accomplished</span>
00287         <span class="comment">// using newReading</span>
00288 
00289         <span class="comment">// Given three consecutive local maps, A, B, and C, with A being the first map built:</span>
00290         <span class="comment">// Pose A is neither localized prior to construction nor relocalized after construction</span>
00291         <span class="comment">//              because there is no current or prior map data to localize against</span>
00292         <span class="comment">// Pose B is localized prior to construction using map data from A, </span>
00293         <span class="comment">//              and relocalized after construction using its own data</span>
00294         <span class="comment">// Pose C is processed in like manner to B, but in reference to B, and so on</span>
00295 
00296         <span class="keyword">static</span> <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a> wCurrentReading_; <span class="comment">// saves reading used for current map's pose</span>
00297         std::string logString;
00298 
00299         <span class="keywordflow">if</span> ( m_currentMap != NULL )
00300         {
00301                 <a class="code" href="classRmPolygon.html">RmPolygon</a> dirtyRegion( m_currentMap-&gt;<a class="code" href="classRmBayesCertaintyGrid.html#a0">bound</a>() );
00302 
00304                 <span class="comment">// Relocalize map just finished building (at t-1)</span>
00305 
00306                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="structRmSettings.html#o7">Localize</a> &amp;&amp; m_maps.size() &gt; 1 ) 
00307                 {
00308                         <span class="comment">// NOTE: m_current map will be non-null and m_maps size will be == 1</span>
00309                         <span class="comment">// at the transition between maps A and B, as described above;</span>
00310                         <span class="comment">// The test for size &gt; 1 prevents a doomed attempt to relocalize map A</span>
00311 
00312                         <span class="comment">// Convolve local map into global map</span>
00313                         <a class="code" href="classRmGlobalMap.html#b0">addToRegionMap</a>( m_currentMap );
00314 
00315                         <span class="comment">// Get updated relocalized pose for local map</span>
00316                         <a class="code" href="classRmLocalMap.html">RmLocalMap</a> &amp;priorMap = *m_maps[m_maps.size() - 2]; <span class="comment">// at transition between B and C, priorMap = A</span>
00317                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gLocPose = <a class="code" href="classRmGlobalMap.html#b6">localizedPose</a>( priorMap, wCurrentReading_, m_debugLog );
00318                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gOldPose = m_currentMap-&gt;<a class="code" href="classRmLocalMap.html#a2">pose</a>().<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> );
00319                         gOldPose.<a class="code" href="structRmUtility_1_1Pose.html#o1">theta</a> = priorMap.<a class="code" href="classRmLocalMap.html#a2">pose</a>().<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a>.<a class="code" href="classRmUtility_1_1Coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ).<a class="code" href="classRmUtility_1_1Coord.html#a1">angleTo</a>( gOldPose.<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a> );
00320                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gPoseShift = gLocPose - gOldPose; <span class="comment">// scaled</span>
00321 
00322                         <span class="comment">// Restore global map to pre-convolved state</span>
00323                         <a class="code" href="classRmGlobalMap.html#b8">removeFromRegionMap</a>( m_currentMap );
00324 
00325                         <span class="comment">// Shift local map by relocalized pose shift</span>
00326                         m_gAccumShift += gPoseShift;
00327                         m_currentMap-&gt;<a class="code" href="classRmLocalMap.html#a3">reorientBy</a>( gPoseShift.<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ) );
00328 
00329                         <span class="comment">// Expand dirty region to include shift</span>
00330                         dirtyRegion.unionWith( <a class="code" href="classRmPolygon.html">RmPolygon</a>( m_currentMap-&gt;<a class="code" href="classRmBayesCertaintyGrid.html#a0">bound</a>() ) );
00331 
00332                         <span class="keywordflow">if</span> ( m_debugLog ) m_debugLog &lt;&lt; <span class="stringliteral">"installNewMap() relocalize : "</span> &lt;&lt; gOldPose &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; gLocPose &lt;&lt; <span class="stringliteral">", "</span> 
00333                                 &lt;&lt; gPoseShift &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; m_gAccumShift &lt;&lt; std::endl;
00334                 }       
00335 
00336 
00338                 <span class="comment">// Convolve newly finished map with global map</span>
00339 
00340                 <span class="comment">// Add to region map</span>
00341                 <a class="code" href="classRmGlobalMap.html#b0">addToRegionMap</a>( m_currentMap );
00342                 logString += <a class="code" href="classRmGlobalMap.html#a6">integrate</a>( dirtyRegion, <span class="keyword">true</span> );
00343 
00344 
00346                 <span class="comment">// Localize new map based on map just finished</span>
00347 
00348                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="structRmSettings.html#o7">Localize</a> ) 
00349                 {
00350                         <span class="comment">// Find delta between selected pose of new and finished local map</span>
00351                         <span class="comment">// Shift local map pose by delta (heading?)</span>
00352                         <span class="comment">// calc angle between coords of current and new map</span>
00353 
00354                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gLocPose = <a class="code" href="classRmGlobalMap.html#b6">localizedPose</a>( *m_currentMap, wNewReading, m_debugLog );
00355                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gPrePose( wNewReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a>.<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ) );
00356                         gPrePose.<a class="code" href="structRmUtility_1_1Pose.html#o1">theta</a> = m_currentMap-&gt;<a class="code" href="classRmLocalMap.html#a2">pose</a>().<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a>.<a class="code" href="classRmUtility_1_1Coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ).<a class="code" href="classRmUtility_1_1Coord.html#a1">angleTo</a>( gPrePose.coord );
00357                         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gPoseShift = gLocPose - gPrePose;
00358                         m_gAccumShift += gPoseShift;
00359 
00360                         <span class="keywordflow">if</span> ( m_debugLog ) m_debugLog &lt;&lt; <span class="stringliteral">"installNewMap() localize : "</span> &lt;&lt; gPrePose &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; gLocPose &lt;&lt; <span class="stringliteral">", "</span> 
00361                                 &lt;&lt; gPoseShift &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; m_gAccumShift &lt;&lt; std::endl;
00362                 }
00363         }
00364 
00365 
00367         <span class="comment">// Create new map, beginning with sonar data just used</span>
00368 
00369         wCurrentReading_ = wNewReading;
00370         wCurrentReading_.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a> = wNewReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a> + m_gAccumShift.<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> );
00371         m_maps.push_back( m_currentMap = <span class="keyword">new</span> <a class="code" href="classRmLocalMap.html">RmLocalMap</a>( m_settings, wCurrentReading_.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a> ) );
00372 
00373         <span class="keywordflow">return</span> logString;
00374 }
00375 
00376 
<a name="l00377"></a><a class="code" href="classRmGlobalMap.html#a6">00377</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#a6">RmGlobalMap::integrate</a>()
00378 {
00379         <span class="comment">// For each cell in the region map (which represents the entire global map)</span>
00380         <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1BoundBox.html">BoundBox</a> <a class="code" href="classRmGlobalMap.html#a0">bound</a>( m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>() );
00381         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = <a class="code" href="classRmGlobalMap.html#a0">bound</a>.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; y &gt;= <a class="code" href="classRmGlobalMap.html#a0">bound</a>.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; --y ) {
00382                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = <a class="code" href="classRmGlobalMap.html#a0">bound</a>.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; x &lt;= <a class="code" href="classRmGlobalMap.html#a0">bound</a>.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; ++x ) 
00383                 {
00384                         <span class="comment">// Store the convolved value of all local maps over the cell</span>
00385                         <span class="keyword">const</span> <a class="code" href="classRmGlobalMap.html#w0">RegionId</a> rId = m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( x, y );
00386                         <a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( x, y ) = <a class="code" href="classRmGlobalMap.html#a2">convolvedValueAt</a>( x, y );
00387                 }
00388         }
00389 }
00390 
00391 
00392 
<a name="l00393"></a><a class="code" href="classRmGlobalMap.html#b5">00393</a> <span class="keyword">const</span> std::string <a class="code" href="classRmGlobalMap.html#a6">RmGlobalMap::integrate</a>( <span class="keyword">const</span> <a class="code" href="classRmPolygon.html">RmPolygon</a> &amp;bound, <span class="keywordtype">bool</span> retVal )
00394 {
00395         <span class="comment">// get cells filling region</span>
00396         std::vector&lt;Coord&gt; fill;
00397         bound.<a class="code" href="classRmPolygon.html#a1">fillInto</a>( &amp;fill );
00398 
00399         <span class="comment">// create update string buffer</span>
00400         <span class="comment">// format is "-xxx -yyy 0.dddd;"</span>
00401         <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[(fill.size() * 17 + 1) * <span class="keyword">sizeof</span>(char)];
00402         <span class="keywordtype">char</span> *buffPtr = buff;
00403         *buffPtr = <span class="charliteral">'\0'</span>;
00404 
00405         <span class="comment">// for each cell</span>
00406         std::vector&lt;Coord&gt;::const_iterator ci;
00407         <span class="keywordflow">for</span> ( ci = fill.begin(); ci != fill.end(); ++ci ) 
00408         {
00409                 <span class="keyword">const</span> <span class="keywordtype">float</span> pr = <a class="code" href="classRmGlobalMap.html#a2">convolvedValueAt</a>( ci-&gt;x, ci-&gt;y );
00410                 <a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( ci-&gt;x, ci-&gt;y ) = pr;
00411                 
00412                 <span class="comment">// update log string by appending over previous terminating null</span>
00413                 <span class="keywordflow">if</span> ( retVal ) {
00414                         sprintf( buffPtr, <span class="stringliteral">"%d %d %.4f;"</span>, ci-&gt;x, ci-&gt;y, pr );
00415                         buffPtr += strlen( buffPtr );
00416                 }
00417         }
00418 
00419         <span class="comment">// tack on local map update string</span>
00420         std::string updateString( buff );
00421         <span class="keyword">delete</span>[] buff;
00422 
00423         <span class="keywordflow">return</span> updateString;
00424 }
00425 
00426 
00427 
00428 <span class="preprocessor">#undef _LOG</span>
00429 <span class="preprocessor"></span>
<a name="l00430"></a><a class="code" href="classRmGlobalMap.html#b6">00430</a> <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> <a class="code" href="classRmGlobalMap.html#b6">RmGlobalMap::localizedPose</a>( 
00431         <span class="keyword">const</span> <a class="code" href="classRmLocalMap.html">RmLocalMap</a> &amp;priorMap, <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a>&amp; wReading, std::ofstream&amp; log )<span class="keyword"> const</span>
00432 <span class="keyword"></span>{
00433         <span class="comment">// Note:  unscaled -&gt; in   out -&gt; scaled</span>
00434 
00435         <span class="keyword">static</span> <span class="keywordtype">int</span> cnt_ = 0;
00436         ++cnt_;
00437 <span class="preprocessor">        #ifdef _LOG</span>
00438 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"\n\nLOCAL MAP "</span> &lt;&lt; ((cnt_+1)/2) &lt;&lt; <span class="stringliteral">"\nDimension: "</span> &lt;&lt; priorMap.<a class="code" href="classRmBayesCertaintyGrid.html#a8">width</a>() &lt;&lt; <span class="stringliteral">" x "</span> &lt;&lt; priorMap.<a class="code" href="classRmBayesCertaintyGrid.html#a3">height</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
00439         log &lt;&lt; <span class="stringliteral">"SonarReading:\n"</span> &lt;&lt; wReading &lt;&lt; <span class="stringliteral">"\n"</span>;
00440 <span class="preprocessor">        #endif</span>
00441 <span class="preprocessor"></span>
00442         <span class="keyword">const</span> <a class="code" href="classRmBayesSonarModel.html">RmBayesSonarModel</a> sonarModel( m_settings ); <span class="comment">// used to calc Pr(Occ)</span>
00443         <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gPose( wReading.robotPose.scaled( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ) );
00444 
00445         <span class="comment">// Calculate probability distribution of pose using motion model</span>
00446         <span class="comment">// Factors:  distance and degree of turns, where</span>
00447         <span class="comment">//    height increases proportionally to distance traveled</span>
00448         <span class="comment">//    width increases proportional to degrees turned</span>
00449         <span class="keyword">const</span> <span class="keywordtype">int</span> h = m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o2">MinHeight</a> + 
00450                 priorMap.<a class="code" href="classRmLocalMap.html#a0">cumDistance</a>() / m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o4">UnitDistance</a>;
00451         <span class="keyword">const</span> <span class="keywordtype">int</span> w = m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o3">MinWidth</a> + 
00452                 priorMap.<a class="code" href="classRmLocalMap.html#a1">cumTurn</a>() / m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o5">UnitTurn</a>;
00453         <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseDist( RmUtility::gaussGrid( w, h, gPose.coord, gPose.theta, 
00454                 m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o1">GaussianSigma</a>, m_settings-&gt;<a class="code" href="structRmSettings.html#o13">MotionModel</a>.<a class="code" href="structRmSettings_1_1MotionModelStruct.html#o0">BendFactor</a> ) );
00455 
00456 <span class="preprocessor">        #ifdef _LOG</span>
00457 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"cumDistance("</span> &lt;&lt; priorMap.<a class="code" href="classRmLocalMap.html#a0">cumDistance</a>()
00458                 &lt;&lt; <span class="stringliteral">") cumTurn("</span> &lt;&lt; priorMap.<a class="code" href="classRmLocalMap.html#a1">cumTurn</a>() &lt;&lt; <span class="stringliteral">") gPoseDist["</span> &lt;&lt; w &lt;&lt; <span class="stringliteral">"]["</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">"]\n"</span>;
00459 <span class="preprocessor">        #endif</span>
00460 <span class="preprocessor"></span>
00461         <span class="comment">//*** Debug</span>
00462         <span class="comment">// #ifndef _USRDLL</span>
00463 <span class="preprocessor">        #ifdef _LOG</span>
00464 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( log )
00465         {
00466                 <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[m_settings-&gt;<a class="code" href="structRmSettings.html#o4">GridName</a>.length() + 7];
00467 
00468                 <span class="comment">// Global map</span>
00469                 sprintf( buff, <span class="stringliteral">"%s%02d.gd"</span>, m_settings-&gt;<a class="code" href="structRmSettings.html#o4">GridName</a>.c_str(), cnt_ );
00470                 <span class="comment">//sprintf( buff, "%s.gd", m_settings-&gt;GridName.c_str() );</span>
00471                 <a class="code" href="classRmGlobalMap.html#a6">integrate</a>();
00472                 <a class="code" href="classRmMutableCartesianGrid.html#a9">RmMutableCartesianGrid&lt;float&gt;::put</a>( buff );
00473 
00474                 <span class="comment">// Global map with pose distributions</span>
00475                 <span class="keyword">static</span> std::vector&lt;RmMutableCartesianGrid&lt;float&gt; &gt; gPoseDists_;
00476                 gPoseDists.push_back( gPoseDist );
00477                 <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gpm( *<span class="keyword">this</span> );
00478                 std::vector&lt;RmMutableCartesianGrid&lt;float&gt; &gt;::const_iterator it;
00479                 <span class="keywordflow">for</span> ( it = gPoseDists_.begin(); it &lt; gPoseDists_.end(); ++it ) gpm.<a class="code" href="classRmMutableCartesianGrid.html#a5">mergeWith</a>( *it );
00480                 sprintf( buff, <span class="stringliteral">"%s%02dp.gd"</span>, m_settings-&gt;<a class="code" href="structRmSettings.html#o4">GridName</a>.c_str(), cnt_ );
00481                 <span class="comment">//sprintf( buff, "%sp.gd", m_settings-&gt;GridName.c_str() );</span>
00482                 gpm.<a class="code" href="classRmMutableCartesianGrid.html#a9">put</a>( buff );
00483 
00484                 <span class="keyword">delete</span>[] buff;
00485         }
00486 <span class="preprocessor">        #endif</span>
00487 <span class="preprocessor"></span>        <span class="comment">// #endif</span>
00488         <span class="comment">//*** End Debug</span>
00489         
00490         <span class="comment">// Histogram matrix over pose for tabulating selected poses for all sonars</span>
00491         <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseHist( gPoseDist );
00492         gPoseHist.<a class="code" href="classRmMutableMatrix.html#a0">clear</a>();
00493         <span class="keywordtype">int</span> maxPoseHist = 0; <span class="comment">// highest value in histogram matrix</span>
00494         
00495         <span class="comment">// Create pose selection matrix, reinitialized for each sonar</span>
00496         <span class="comment">// Note: while gPoseSel is a histogrammic matrix, are using float rather than int because can't</span>
00497         <span class="comment">// easily copy configuration of gPoseDist any other way, and template class copy constructor</span>
00498         <span class="comment">// requires same type.</span>
00499         <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseSel( gPoseDist ); <span class="comment">// convolves prOcc with gPoseDist</span>
00500 <span class="preprocessor">        #ifdef _LOG</span>
00501 <span class="preprocessor"></span>        <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseObs( gPoseDist ); <span class="comment">// tracks obstructions; log use only</span>
00502         <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseGlo( gPoseDist ); <span class="comment">// global map about range reading; log use only</span>
00503         <a class="code" href="classRmMutableCartesianGrid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseOcc( gPoseDist ); <span class="comment">// occ grid about range reading; log use only</span>
00504         gPoseOcc.<a class="code" href="classRmMutableMatrix.html#a12">setInitValue</a>( 0.5f );
00505 <span class="preprocessor">        #endif</span>
00506 <span class="preprocessor"></span>
00507         <span class="comment">// For each sonar</span>
00508         <span class="keywordtype">bool</span> noneInRange = <span class="keyword">true</span>; <span class="comment">// indicates no sonar readings in range</span>
00509         <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a> wReadingCopy( wReading ); <span class="comment">// _UNSCALED_LOCALIZATION copy to be modified</span>
00510         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; RmPioneerController::NumSonars; ++i )
00511         {
00512                 <span class="comment">// Calc grid-based vector (direction and magnitude) for the range reading</span>
00513                 wReadingCopy.<a class="code" href="structRmUtility_1_1SonarReading.html#o3">sonarNumber</a> = i;
00514                 wReadingCopy.<a class="code" href="structRmUtility_1_1SonarReading.html#o1">distance</a> = wReadingCopy.<a class="code" href="structRmUtility_1_1SonarReading.html#o0">all</a>[i];
00515                 <a class="code" href="structRmUtility_1_1MappedSonarReading.html">MappedSonarReading</a> &amp;gMR = 
00516                         <a class="code" href="classRmPioneerController.html#e1">RmPioneerController::rangeReading</a>( wReadingCopy ).<a class="code" href="structRmUtility_1_1MappedSonarReading.html#a1">scale</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> );
00517                         <span class="comment">// rangeReading() is best used with unscaled data</span>
00518 <span class="preprocessor">                #ifdef _LOG</span>
00519 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gMR;
00520 <span class="preprocessor">                #endif</span>
00521 <span class="preprocessor"></span>
00522                 <span class="comment">// Skip out-of-range readings</span>
00523                 <span class="comment">// (placed after calculation of mr so mr log entry can first be entered)</span>
00524                 <span class="keywordflow">if</span> ( wReadingCopy.<a class="code" href="structRmUtility_1_1SonarReading.html#o1">distance</a> &gt; RmPioneerController::SonarRange ) {
00525 <span class="preprocessor">                        #ifdef _LOG</span>
00526 <span class="preprocessor"></span>                        log &lt;&lt; <span class="stringliteral">"Skipping out of range reading.\n"</span>;
00527 <span class="preprocessor">                        #endif</span>
00528 <span class="preprocessor"></span>                        <span class="keywordflow">continue</span>;
00529                 }
00530                 noneInRange = <span class="keyword">false</span>;
00531 
00532 
00533                 <span class="comment">// Init pose selection and log matrices</span>
00534                 gPoseSel.<a class="code" href="classRmMutableMatrix.html#a0">clear</a>();
00535 <span class="preprocessor">                #ifdef _LOG</span>
00536 <span class="preprocessor"></span>                gPoseObs.<a class="code" href="classRmMutableMatrix.html#a0">clear</a>();
00537                 gPoseOcc.<a class="code" href="classRmMutableCartesianGrid.html#a14">setOrigin</a>( gMR.objectCoord );
00538                 gPoseOcc.<a class="code" href="classRmMutableMatrix.html#a0">clear</a>();
00539 <span class="preprocessor">                #endif</span>
00540 <span class="preprocessor"></span>
00541                 <span class="comment">// For each cell in pose distribution matrix</span>
00542                 <span class="keywordtype">float</span> maxPoseSel = 0.0; <span class="comment">// highest value in pose selection matrix</span>
00543                 <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1BoundBox.html">BoundBox</a> gBound = gPoseDist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>();
00544                 <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gSonarShift = gMR.sonarPose.coord - gPose.coord;
00545                 <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gObjectShift = gMR.objectCoord - gMR.sonarPose.coord;
00546                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; gY &gt;= gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; --gY ) {
00547                         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; gX &lt;= gBound.<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; ++gX ) 
00548                         {
00549                                 <span class="comment">// If cell at terminal end of range reading vector is unobstructed, </span>
00550                                 <span class="comment">// record pose selection likelihood</span>
00551                                 <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gStart = <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>( gX, gY ) + gSonarShift;
00552                                 <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gEnd = gStart + gObjectShift;
00553                                 <span class="keywordflow">if</span> ( !<a class="code" href="classRmGlobalMap.html#a7">obstructionBetween</a>( gStart, gEnd ) ) 
00554                                 {
00555 <span class="preprocessor">                                        #ifdef _LOG</span>
00556 <span class="preprocessor"></span>                                        <span class="comment">// Record unostructed path for log output</span>
00557                                         gPoseObs[gX][gY] = 1.0f;
00558 <span class="preprocessor">                                        #endif</span>
00559 <span class="preprocessor"></span>
00560                                         <span class="comment">// get prior prob of occupied from global map</span>
00561                                         <span class="keyword">const</span> <span class="keywordtype">float</span> priorPrOcc = <a class="code" href="classRmGlobalMap.html#a2">convolvedValueAt</a>( gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>, gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a> );
00562 
00563                                         <span class="comment">// get new prob of occupied for this pose dist cell</span>
00564                                         <span class="keyword">const</span> <span class="keywordtype">float</span> prOcc = sonarModel.<a class="code" href="classRmBayesSonarModel.html#a0">prOccupiedGivenSn</a>( 
00565                                                 priorPrOcc, RmBayesSonarModel::RegionI, gMR.reading.distance );
00566 <span class="preprocessor">                                        #ifdef _LOG</span>
00567 <span class="preprocessor"></span>                                        gPoseOcc[gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>][gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>] = prOcc;
00568 <span class="preprocessor">                                        #endif</span>
00569 <span class="preprocessor"></span>
00570                                         <span class="keyword">const</span> <span class="keywordtype">float</span> s = gPoseSel[gX][gY] = prOcc * gPoseDist[gX][gY];
00571                                         
00572                                         <span class="keywordflow">if</span> ( s &gt; maxPoseSel ) maxPoseSel = s;
00573                                 }
00574                         }
00575                 }
00576 
00577                 <span class="comment">// Increment in pose histogram the cells corresponding to </span>
00578                 <span class="comment">// those in pose selection matrix with highest prob</span>
00579                 <span class="keywordflow">if</span> ( maxPoseSel &gt; 0 ) {
00580                         <span class="keywordflow">for</span> ( gY = gPoseSel.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; gY &gt;= gPoseSel.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; --gY ) {
00581                                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gPoseSel.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; gX &lt;= gPoseSel.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; ++gX ) 
00582                                 {
00583                                         <span class="keywordflow">if</span> ( gPoseSel[gX][gY] == maxPoseSel ) {
00584                                                 <span class="keyword">const</span> <span class="keywordtype">int</span> h = ++gPoseHist[gX][gY]; <span class="comment">// store so don't have to call [][] twice</span>
00585                                                 <span class="keywordflow">if</span> ( h &gt; maxPoseHist ) maxPoseHist = h;
00586                                         }
00587                                 }
00588                         }
00589                 }
00590 
00591 <span class="preprocessor">                #ifdef _LOG</span>
00592 <span class="preprocessor"></span>                gPoseGlo.<a class="code" href="classRmMutableCartesianGrid.html#a14">setOrigin</a>( gMR.objectCoord );
00593                 <a class="code" href="classRmMutableCartesianGrid.html#a1">copyInto</a>( gPoseGlo );
00594                 log &lt;&lt; <span class="stringliteral">"PrOcc at object = "</span> &lt;&lt; gPoseOcc[gMR.objectCoord.x][gMR.objectCoord.y] &lt;&lt; <span class="stringliteral">", prior = "</span> &lt;&lt; gPoseGlo[gMR.objectCoord.x][gMR.objectCoord.y] &lt;&lt; <span class="stringliteral">"\n"</span>;
00595                 log &lt;&lt; <span class="stringliteral">"\nposeDistribution over Robot Pose, by local map, "</span> &lt;&lt; <span class="stringliteral">"Bound: "</span> &lt;&lt; gPoseDist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>() &lt;&lt; <span class="stringliteral">" Origin: "</span> 
00596                         &lt;&lt; gPoseDist.origin() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gPoseDist;
00597                 log &lt;&lt; <span class="stringliteral">"\nglobalMap over Object, by sonar, "</span> &lt;&lt; <span class="stringliteral">"Bound: "</span> &lt;&lt; gPoseGlo.bound() &lt;&lt; <span class="stringliteral">" Origin: "</span> 
00598                         &lt;&lt; gPoseGlo.origin() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gPoseGlo;
00599                 log &lt;&lt; <span class="stringliteral">"\nposeObstructions over Object, by sonar, 0 = obstructed (path from Robot Pose to Object)\n"</span> &lt;&lt; gPoseObs;
00600                 log &lt;&lt; <span class="stringliteral">"\nprOcc over Object, by unobstructed sonar\n"</span> &lt;&lt; gPoseOcc;
00601                 log &lt;&lt; <span class="stringliteral">"\nposeSelelections over Object, by sonar (gPoseDist * prOcc * gPoseObs)\n"</span> &lt;&lt; gPoseSel &lt;&lt; <span class="stringliteral">"\n"</span>;
00602                 log &lt;&lt; <span class="stringliteral">"poseHistogram over Robot Pose, by local map (max gPoseSel)\n"</span> &lt;&lt; gPoseHist &lt;&lt; <span class="stringliteral">"\n"</span>;
00603                 
00604                 log &lt;&lt; <span class="stringliteral">"===== End Sonar "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"\n"</span>;
00605 <span class="preprocessor">                #endif</span>
00606 <span class="preprocessor"></span>        }
00607 
00608         <span class="comment">// If no poses were selected, all sonar readings were out of range</span>
00609         <span class="comment">// Can only return original pose</span>
00610         <span class="keywordflow">if</span> ( maxPoseHist == 0 ) {
00611 <span class="preprocessor">                #ifdef _LOG</span>
00612 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"\nNo sonar readings in range!\n\n"</span>;
00613 <span class="preprocessor">                #endif</span>
00614 <span class="preprocessor"></span>                <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gLocPose( wReading.robotPose.scaled( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ) );
00615                 gLocPose.theta = priorMap.<a class="code" href="classRmLocalMap.html#a2">pose</a>().<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a>.<a class="code" href="classRmUtility_1_1Coord.html#a1">angleTo</a>( wReading.robotPose.coord );
00616                 <span class="keywordflow">return</span> gLocPose;
00617         }
00618 
00619         <span class="comment">// Get poses with max pose histogram value and record corresponding max post dist value</span>
00620         std::vector&lt;Coord&gt; gSelectedPoses;
00621         <span class="keywordtype">float</span> maxSelPoseDist = 0.0f;
00622         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gPoseHist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; gY &gt;= gPoseHist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>; --gY ) {
00623                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gPoseHist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o1">ul</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; gX &lt;= gPoseHist.<a class="code" href="classRmMutableCartesianGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#o0">lr</a>.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>; ++gX ) 
00624                 {
00625                         <span class="keywordflow">if</span> ( gPoseHist[gX][gY] == maxPoseHist ) {
00626                                 gSelectedPoses.push_back( <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>( gX, gY ) );
00627                                 <span class="keyword">const</span> <span class="keywordtype">float</span> pd = gPoseDist[gX][gY]; <span class="comment">// store so don't have to call [][] twice</span>
00628                                 <span class="keywordflow">if</span> ( pd &gt; maxSelPoseDist ) maxSelPoseDist = pd;
00629                         }
00630                 }
00631         }
00632 
00633         <span class="comment">// Filter all but those with the highest underlying maximum pose distribution</span>
00634         log &lt;&lt; <span class="stringliteral">"maxSelPoseDist = "</span> &lt;&lt; maxSelPoseDist &lt;&lt; <span class="stringliteral">"\n"</span>;
00635         std::vector&lt;Coord&gt;::iterator gSelectedPose = gSelectedPoses.begin();
00636         <span class="keywordflow">while</span> ( gSelectedPose &lt; gSelectedPoses.end() )
00637         {
00638                 <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gc( *gSelectedPose );
00639                 log &lt;&lt; gc &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; gPoseDist[gc.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>][gc.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>] &lt;&lt; <span class="stringliteral">" "</span>;
00640                 <span class="keywordflow">if</span> ( gPoseDist[gc.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>][gc.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>] &lt; maxSelPoseDist ) {
00641                         gSelectedPoses.erase( gSelectedPose ); <span class="comment">// implicit ++gSelectedPose</span>
00642                         log &lt;&lt; <span class="stringliteral">"erased\n"</span>;
00643                 }
00644                 <span class="keywordflow">else</span> {
00645                         ++gSelectedPose;
00646                         log &lt;&lt; <span class="stringliteral">"retained\n"</span>;
00647                 }
00648         }
00649 
00650         <span class="comment">// If more than one selected pose, take the first (for now)</span>
00651         <span class="keywordflow">if</span> ( gSelectedPoses.size() != 1 ) 
00652         {
00653 <span class="preprocessor">                #ifdef _LOG</span>
00654 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"maxSelPoseDist = "</span> &lt;&lt; maxSelPoseDist &lt;&lt; <span class="stringliteral">"\n"</span>;
00655                 log &lt;&lt; <span class="stringliteral">"candidate poses: "</span>;
00656                 <span class="keywordflow">for</span> ( gSelectedPose = gSelectedPoses.begin(); gSelectedPose &lt; gSelectedPoses.end(); ++gSelectedPose )
00657                 {
00658                         log &lt;&lt; *gSelectedPose &lt;&lt; <span class="stringliteral">" "</span>;
00659                 }
00660                 log &lt;&lt; <span class="stringliteral">"\n"</span>;
00661 <span class="preprocessor">                #endif</span>
00662 <span class="preprocessor"></span>                <span class="keywordtype">char</span> buff[50];
00663                 sprintf( buff, <span class="stringliteral">"%d poses remain in filtered selection matrix"</span>, gSelectedPoses.size() );
00664                 <a class="code" href="structRmExceptions_1_1Exception.html">RmExceptions::Exception</a> e( NULL, <span class="stringliteral">"RmGlobalMap::localizedPose()"</span>, buff );
00665 
00666                 <span class="comment">// This isn't an "error" so much as it is a condition;</span>
00667                 <span class="comment">// Notify and keep going</span>
00668                 std::cerr &lt;&lt; e;
00669 
00670                 <span class="comment">// Additional filters for narrowing down selections:</span>
00671                 <span class="comment">// - highest avg of surrounding cells, etc.</span>
00672                 <span class="comment">// - closes proximity to original pose</span>
00673         }
00674 
00675         <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> gSelCoord( gSelectedPoses.front() );
00676 
00677         <span class="comment">// Return the selected position and angle to that pos from current map's starting position</span>
00678         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gLocPose( gSelCoord, priorMap.<a class="code" href="classRmLocalMap.html#a2">pose</a>().<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a>.<a class="code" href="classRmUtility_1_1Coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ).<a class="code" href="classRmUtility_1_1Coord.html#a1">angleTo</a>( gSelCoord ) );
00679 
00680 <span class="preprocessor">        #ifdef _LOG</span>
00681 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"selPose: "</span> &lt;&lt; gLocPose &lt;&lt; std::endl;
00682 <span class="preprocessor">        #endif</span>
00683 <span class="preprocessor"></span>
00684         <span class="keywordflow">return</span> gLocPose;
00685 }
00686 
00687 
<a name="l00688"></a><a class="code" href="classRmGlobalMap.html#b7">00688</a> <a class="code" href="structRmGlobalMap_1_1Region.html">RmGlobalMap::Region</a>* <a class="code" href="classRmGlobalMap.html#b7">RmGlobalMap::newRegion</a>( <span class="keyword">const</span> <a class="code" href="classRmPolygon.html">RmPolygon</a> &amp;bound )
00689 {
00690         <a class="code" href="classRmGlobalMap.html#w0">RegionId</a> id;
00691         <span class="keywordflow">if</span> ( m_usedRegionIds.empty() ) <span class="keywordtype">id</span> = ++m_maxRegionId;
00692         <span class="keywordflow">else</span> {
00693                 <span class="keywordtype">id</span> = m_usedRegionIds.front();
00694                 m_usedRegionIds.pop();
00695         }
00696 
00697         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *r = <span class="keyword">new</span> <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a>( <span class="keywordtype">id</span>, bound );
00698         m_regions[id] = r;
00699         
00700         <a class="code" href="classRmGlobalMap.html#b3">fillRegionMap</a>( r, <span class="keywordtype">id</span> );
00701 
00702         <span class="keywordflow">return</span> r;
00703 }
00704 
00705 
<a name="l00706"></a><a class="code" href="classRmGlobalMap.html#a7">00706</a> <span class="keywordtype">bool</span> <a class="code" href="classRmGlobalMap.html#a7">RmGlobalMap::obstructionBetween</a>( <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>&amp; gStart, <span class="keyword">const</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a>&amp; gEnd )<span class="keyword"> const</span>
00707 <span class="keyword"></span>{
00708         <span class="comment">// Reasons for differences from original:</span>
00709         <span class="comment">// - Checking for obstruction to gcObject rather than f (in RmBayesCertaintyGrid obstruction check)</span>
00710         <span class="comment">// - Not processing last point in linePointList</span>
00711         <span class="comment">// - Checking global map</span>
00712 
00713         <span class="keywordtype">bool</span> obstructed = <span class="keyword">false</span>;
00714         <span class="keywordtype">float</span> prGlobal = 0.0f;
00715         <span class="keywordtype">float</span> prLocal = 0.0f;
00716         <span class="keyword">const</span> <span class="keywordtype">float</span> prObstr = m_settings-&gt;<a class="code" href="structRmSettings.html#o14">ObstructedCertainty</a>;
00717 
00718         <span class="keywordflow">for</span> ( PointList* gLinePointList = FillLine( gStart.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>, gStart.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a>, gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o0">x</a>, gEnd.<a class="code" href="classRmUtility_1_1Coord.html#o1">y</a> ); <span class="comment">// [start..end)</span>
00719                 gLinePointList; gLinePointList = gLinePointList-&gt;next )
00720         {
00721                 <span class="keyword">const</span> <span class="keywordtype">int</span> gX = gLinePointList-&gt;point.X;
00722                 <span class="keyword">const</span> <span class="keywordtype">int</span> gY = gLinePointList-&gt;point.Y;
00723 
00724                 <span class="comment">// These tests short-circuit further testing of either local or global bounds </span>
00725                 <span class="comment">// once it has been determined one of them has been exceeded</span>
00726                 <span class="keywordtype">int</span> oneInBounds = 0;
00727                 <span class="keywordflow">if</span> ( prGlobal != -1.0f ) {
00728                         <span class="keywordflow">if</span> ( m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a4">inBounds</a>( gX, gY ) ) {
00729                                 prGlobal = <a class="code" href="classRmGlobalMap.html#a2">convolvedValueAt</a>( gX, gY );
00730                                 ++oneInBounds;
00731                         }
00732                         <span class="keywordflow">else</span> prGlobal = -1.0f;
00733                 }
00734                 <span class="keywordflow">if</span> ( prLocal != -1.0f ) {
00735                         <span class="keywordflow">if</span> ( m_currentMap-&gt;<a class="code" href="classRmMutableCartesianGrid.html#a4">inBounds</a>( gX, gY ) ) {
00736                                 prLocal = m_currentMap-&gt;<a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( gX, gY );
00737                                 ++oneInBounds;
00738                         }
00739                         <span class="keywordflow">else</span> prLocal = -1.0f;
00740                 }
00741 
00742                 <span class="comment">// This test short-circuits all future testing if neither one are in-bounds</span>
00743                 <span class="keywordflow">if</span> ( !oneInBounds ) 
00744                         <span class="keywordflow">break</span>;
00745 
00746                 <span class="keywordflow">if</span> ( prLocal &gt;= prObstr || prGlobal &gt;= prObstr )
00747                 {
00748                         obstructed = <span class="keyword">true</span>;
00749                         <span class="keywordflow">break</span>;
00750                 }
00751         }
00752 
00753         <span class="keywordflow">return</span> obstructed;
00754 }
00755 
00756 
<a name="l00757"></a><a class="code" href="classRmGlobalMap.html#a8">00757</a> std::ostream&amp; <a class="code" href="classRmGlobalMap.html#a8">RmGlobalMap::put</a>( std::ostream&amp; os )<span class="keyword"> const</span>
00758 <span class="keyword"></span>{ 
00759         m_settings-&gt;<a class="code" href="structRmSettings.html#a2">put</a>( os, <span class="stringliteral">"% "</span> );
00760 
00761         <span class="keywordflow">return</span> <a class="code" href="classRmBayesCertaintyGrid.html#a4">RmBayesCertaintyGrid::put</a>( os );
00762 }
00763 
00764 
<a name="l00765"></a><a class="code" href="classRmGlobalMap.html#b8">00765</a> <span class="keywordtype">void</span> <a class="code" href="classRmGlobalMap.html#b8">RmGlobalMap::removeFromRegionMap</a>( <a class="code" href="classRmLocalMap.html">RmLocalMap</a> *map )
00766 {
00767         assert( map != NULL );
00768 
00769         <span class="comment">// Set up tracking of processed regions</span>
00770         std::set&lt;RegionId&gt; regionsProcessed;
00771         regionsProcessed.insert( 0 ); <span class="comment">// non-region has id of 0, which is treated as processed</span>
00772 
00773         <span class="comment">// For each cell within the map's bounds (with explicit inclusion of n/e borders)</span>
00774         <a class="code" href="classRmPolygon.html">RmPolygon</a> bo( map-&gt;<a class="code" href="classRmBayesCertaintyGrid.html#a0">bound</a>().<a class="code" href="structRmUtility_1_1BoundBox.html#a3">expandBy</a>( 1, 0, 1, 0 ) );
00775         std::vector&lt;Coord&gt; fill;
00776         bo.fillInto( &amp;fill );
00777         std::vector&lt;Coord&gt;::const_iterator ci;
00778         <span class="keywordflow">for</span> ( ci = fill.begin(); ci != fill.end(); ++ci ) 
00779         {
00780                 <span class="comment">// For regions not already processed</span>
00781                 <span class="keyword">const</span> <a class="code" href="classRmGlobalMap.html#w0">RegionId</a> regionId = m_regionMap.<a class="code" href="classRmMutableCartesianGrid.html#a18">valueAt</a>( ci-&gt;x, ci-&gt;y );
00782                 <span class="keywordflow">if</span> ( regionsProcessed.count( regionId ) == 0 ) 
00783                 {
00784                         <span class="comment">// Remove the map from the region</span>
00785                         <a class="code" href="structRmGlobalMap_1_1Region.html">Region</a> *r = m_regions[regionId];
00786                         r-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.erase( map );
00787 
00788                         <span class="comment">// If no maps cover the region any longer, delete it</span>
00789                         <span class="keywordflow">if</span> ( r-&gt;<a class="code" href="structRmGlobalMap_1_1Region.html#o2">maps</a>.size() == 0 ) <a class="code" href="classRmGlobalMap.html#b2">deleteRegion</a>( &amp;r );
00790 
00791                         <span class="comment">// Mark region as processed</span>
00792                         regionsProcessed.insert( regionId );
00793                 }
00794         }
00795 }
00796 
00797 
<a name="l00798"></a><a class="code" href="classRmGlobalMap.html#a10">00798</a> <span class="keyword">const</span> std::string <a class="code" href="classRmGlobalMap.html#a10">RmGlobalMap::update</a>( <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a>&amp; wReading )
00799 {
00800         <span class="keywordflow">if</span> ( m_finalized ) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00801 
00802         <span class="comment">// Accummulate distance traveled for current map</span>
00803         <span class="keyword">static</span> <span class="keywordtype">bool</span> newMap_ = <span class="keyword">true</span>;
00804         <span class="keyword">static</span> <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> wLastPos_;
00805         <a class="code" href="classRmUtility_1_1Coord.html">Coord</a> wCurrPos = wReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a>.<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a>;
00806         <span class="keywordflow">if</span> ( !newMap_ ) m_wDistance += wLastPos_.<a class="code" href="classRmUtility_1_1Coord.html#a3">distanceFrom</a>( wCurrPos );
00807         wLastPos_ = wCurrPos;
00808         newMap_ = <span class="keyword">false</span>;
00809 
00810         <span class="comment">// Initialize new map on first run</span>
00811         <span class="comment">// Would do in constructor but would have to assume origin pose of Pose()</span>
00812         std::string newMapString;
00813         <span class="keywordflow">if</span> ( m_currentMap == NULL )
00814         {
00815                 m_debugLog &lt;&lt; <span class="stringliteral">"Settings:\n"</span> &lt;&lt; *m_settings &lt;&lt; <span class="stringliteral">"\n"</span>;
00816                 newMapString = <a class="code" href="classRmGlobalMap.html#b4">installNewMap</a>( wReading );
00817         }
00818 
00819         <span class="comment">// If total distance exceeds prescribed amount</span>
00820         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="structRmSettings.html#o8">LocalMapDistance</a> &gt; 0 &amp;&amp; m_wDistance &gt; m_settings-&gt;<a class="code" href="structRmSettings.html#o8">LocalMapDistance</a> )
00821         {
00822                 <span class="comment">// Create new map</span>
00823                 <span class="comment">// Add to map collection</span>
00824                 <span class="comment">// Set current local map to new map</span>
00825                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="structRmSettings.html#o7">Localize</a> ) newMapString = <a class="code" href="classRmGlobalMap.html#b4">installNewMap</a>( wReading );
00826                 <span class="keywordflow">else</span> <a class="code" href="classRmGlobalMap.html#b4">installNewMap</a>( wReading );
00827 
00828                 newMap_ = <span class="keyword">true</span>;
00829                 m_wDistance = 0.0;
00830         }
00831 
00832         <span class="comment">// Modify reading by pose shift updated in installNewMap()</span>
00833         <a class="code" href="structRmUtility_1_1SonarReading.html">SonarReading</a> wShiftedReading( wReading );
00834         wShiftedReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a> += m_gAccumShift.<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> );
00835 
00836         <span class="comment">// Prepare default pose string</span>
00837         <a class="code" href="structRmUtility_1_1Pose.html">Pose</a> gRobotPose( wShiftedReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a>.<a class="code" href="structRmUtility_1_1Pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="structRmSettings.html#o2">CellSize</a> ) );
00838         <span class="keywordtype">char</span> logPose[30];
00839         sprintf( logPose, <span class="stringliteral">"%d %d %d %d %d\n"</span>, gRobotPose.coord.x, gRobotPose.coord.y, 
00840                 static_cast&lt;int&gt;(wReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o2">robotPose</a>.<a class="code" href="structRmUtility_1_1Pose.html#o1">theta</a>), wReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o3">sonarNumber</a>, wReading.<a class="code" href="structRmUtility_1_1SonarReading.html#o1">distance</a> );
00841 
00842         <span class="comment">// Skip obstructed readings (cell and axis models only)</span>
00843         <span class="keyword">const</span> <a class="code" href="structRmUtility_1_1MappedSonarReading.html">RmUtility::MappedSonarReading</a> wMR = <a class="code" href="classRmPioneerController.html#e1">RmPioneerController::rangeReading</a>( wShiftedReading );
00844         <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="structRmSettings.html#o19">SonarModel</a> != RmUtility::Cone &amp;&amp; m_settings-&gt;<a class="code" href="structRmSettings.html#o5">IgnoreObstructed</a> &amp;&amp; 
00845                 <a class="code" href="classRmGlobalMap.html#a7">obstructionBetween</a>( <a class="code" href="classRmBayesCertaintyGrid.html#b1">gridCoord</a>( wMR.<a class="code" href="structRmUtility_1_1MappedSonarReading.html#o2">sonarPose</a>.<a class="code" href="structRmUtility_1_1Pose.html#o0">coord</a> ), gridCoord( wMR.<a class="code" href="structRmUtility_1_1MappedSonarReading.html#o0">objectCoord</a> ) ) ) {
00846                 <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00847         }
00848 
00849         <span class="comment">// Pass reading on to current local map</span>
00850         std::string logString = m_currentMap-&gt;<a class="code" href="classRmLocalMap.html#a7">update</a>( wMR );
00851 
00852         <span class="comment">// If update string is empty (due to out-of-range or disabled sonar)</span>
00853         <span class="comment">// but we have a new map update string, include log line 1 for return to viewer</span>
00854         <span class="keywordflow">if</span> ( logString.length() == 0 &amp;&amp; newMapString.length() &gt; 0 ) logString = logPose;
00855         <span class="keywordflow">else</span> logString = logString.substr( 0, logString.length() - 2 );
00856         logString += newMapString;
00857 
00858         <span class="keywordflow">return</span> logString;
00859 }
00860 
00861 
00862 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00863 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v )
00864 {
00865         std::vector&lt;T&gt;::const_iterator it;
00866         <span class="keywordflow">for</span>( it = v.begin(); it != v.end(); ++it ) {
00867                 os &lt;&lt; *it &lt;&lt; <span class="stringliteral">" "</span>;
00868         }
00869         <span class="keywordflow">return</span> os;
00870 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 1 23:40:03 2005 for Robot Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
