<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Robot Mapper: include/RmMutableMatrix.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a></div>
<h1>RmMutableMatrix.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * RmMutableMatrix.h</span>
00003 <span class="comment"> * </span>
00004 <span class="comment"> * Defines:</span>
00005 <span class="comment"> * - template&lt;class T&gt; class RmMutableMatrix</span>
00006 <span class="comment"> * - template&lt;class T&gt; class Operator2D (internal use only)</span>
00007 <span class="comment"> * </span>
00008 <span class="comment"> * Purpose:</span>
00009 <span class="comment"> * Provides a vector&lt;T&gt;-based two-dimensional matrix that is dynamically expanded either</span>
00010 <span class="comment"> * explicitly using ::resizeBy() or automatically using ::operator[][].</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * Author:</span>
00013 <span class="comment"> * Capt Kevin Owens</span>
00014 <span class="comment"> * Air Force Institute of Technology</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * Revisions:</span>
00017 <span class="comment"> * 12 Nov 2004: created</span>
00018 <span class="comment"> * 21 Nov 2004: "const-ified" ostream&amp; operator&lt;&lt;() iterator and parameter</span>
00019 <span class="comment"> * 27 Nov 2004: Moved MMAccessor inside RmMutableMatrix and renamed to Operator2D</span>
00020 <span class="comment"> *                              Added put() and valueAt(), calling from operator&lt;&lt; and operator[], respectively</span>
00021 <span class="comment"> *                              cppdoc documentation</span>
00022 <span class="comment"> * 15 Dec 2004: added const overloads to valueAt(), operator[], and Operator2D&lt;T&gt;</span>
00023 <span class="comment"> * 21 Dec 2004: fixed bug in valueAt() where 0-sized matrix wasn't resized</span>
00024 <span class="comment"> *                              accommodated inheritance by RmMutableCartesianGrid&lt;T&gt; (virtuals, scope resolutions)</span>
00025 <span class="comment"> *                              added operator=()</span>
00026 <span class="comment"> */</span>
00027 
00028 
00029 <span class="preprocessor">#ifndef RM_MUTABLE_MATRIX_H</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define RM_MUTABLE_MATRIX_H</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#include &lt;vector&gt;</span>
00033 <span class="preprocessor">#include &lt;iostream&gt;</span>
00034 <span class="preprocessor">#include &lt;cmath&gt;</span>
00035 <span class="preprocessor">#include &lt;cassert&gt;</span>
00036 <span class="preprocessor">#include "RmExceptions.h"</span>
00037 <span class="preprocessor">#include "RmUtility.h"</span>
00038 
00039 
00083 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00084"></a><a class="code" href="class_rm_mutable_matrix.html">00084</a> <span class="keyword">class </span><a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix</a>
00085 {
00086 <span class="keyword">public</span>:
00087 
00092         <span class="comment">// This is public so that a using class may itself provide this [][] functionality without</span>
00093         <span class="comment">// implementing it directly; see RmBayesCertaintyGrid for an example.</span>
00094         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
<a name="l00095"></a><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html">00095</a>         <span class="keyword">class </span><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html">Operator2D</a>
00096         {
00097         <span class="keyword">public</span>:
00098 
<a name="l00105"></a><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html#a1">00105</a>                 <a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html">Operator2D</a>( <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a>* v, <span class="keywordtype">int</span> x ) : m_m2v(v), m_m2vc(NULL), m_x(x) {}
00106 
00107 
<a name="l00111"></a><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html#a0">00111</a>                 <a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html">Operator2D</a>( <span class="keyword">const</span> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a>* v, <span class="keywordtype">int</span> x ) : m_m2v(NULL), m_m2vc(v), m_x(x) {}
00112 
00113 
<a name="l00120"></a><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html#a3">00120</a>                 T&amp; operator[]( <span class="keywordtype">int</span> y ) { 
00121                         <span class="keywordflow">return</span> m_m2v-&gt;valueAt( m_x, y ); }
00122 
00123 
<a name="l00127"></a><a class="code" href="class_rm_mutable_matrix_1_1_operator2_d.html#a2">00127</a>                 <span class="keyword">const</span> T&amp; operator[]( <span class="keywordtype">int</span> y )<span class="keyword"> const </span>{ 
00128                         <span class="keywordflow">return</span> m_m2vc-&gt;valueAt( m_x, y ); }
00129 
00130         <span class="keyword">private</span>:
00131 
00132                 <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a>* m_m2v;
00133                 <span class="keyword">const</span> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a>* m_m2vc;
00134                 <span class="keyword">const</span> <span class="keywordtype">int</span> m_x;
00135         };
00136 
00137 
00148         <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix</a>( <span class="keywordtype">int</span> w = 10, <span class="keywordtype">int</span> h = 10, <span class="keyword">const</span> T initVal = T(), <span class="keyword">const</span> <span class="keywordtype">char</span>* colSep = <span class="stringliteral">" "</span>,
00149                 <span class="keyword">const</span> <span class="keywordtype">char</span>* rowSep = <span class="stringliteral">"\n"</span>, <span class="keywordtype">bool</span> autoResize = <span class="keyword">true</span> );
00150 
00151 
00155         <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix</a>&amp; operator= ( <span class="keyword">const</span> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix</a>&amp; source );
00156 
00157 
<a name="l00162"></a><a class="code" href="class_rm_mutable_matrix.html#a12">00162</a>         <span class="keywordtype">void</span> setInitValue( <span class="keyword">const</span> T initVal ) { m_initVal = initVal; }
00163 
00164 
<a name="l00168"></a><a class="code" href="class_rm_mutable_matrix.html#a3">00168</a>         T initValue( )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_initVal; }
00169         
00170 
00187         <span class="keyword">virtual</span> <span class="keywordtype">void</span> resizeBy( <span class="keywordtype">int</span> north, <span class="keywordtype">int</span> south, <span class="keywordtype">int</span> east, <span class="keywordtype">int</span> west );
00188 
00189 
00200         <span class="keyword">virtual</span> <span class="keywordtype">void</span> rotateBy( <span class="keyword">const</span> <span class="keywordtype">double</span> theta );
00201 
00202 
00208         <span class="keyword">virtual</span> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a> rotatedBy( <span class="keyword">const</span> <span class="keywordtype">double</span> theta ) <span class="keyword">const</span>;
00209 
00210 
00214         <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear();
00215 
00216 
00220         <span class="keyword">virtual</span> <span class="keywordtype">void</span> empty();
00221 
00222 
<a name="l00226"></a><a class="code" href="class_rm_mutable_matrix.html#a2">00226</a>         <span class="keywordtype">int</span> height()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_height; }
00227 
00228 
<a name="l00232"></a><a class="code" href="class_rm_mutable_matrix.html#a15">00232</a>         <span class="keywordtype">int</span> width()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_width; }
00233 
00234 
00256         <span class="keyword">virtual</span> T&amp; valueAt( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y );
00257 
00258         
00264         <span class="keyword">virtual</span> <span class="keyword">const</span> T&amp; valueAt( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y ) <span class="keyword">const</span>;
00265 
00266 
<a name="l00273"></a><a class="code" href="class_rm_mutable_matrix.html#a6">00273</a>         Operator2D&lt;T&gt; operator[]( <span class="keywordtype">int</span> x ) { 
00274                 <span class="keywordflow">return</span> Operator2D&lt;T&gt;( <span class="keyword">this</span>, x ); }
00275 
00276         
<a name="l00280"></a><a class="code" href="class_rm_mutable_matrix.html#a5">00280</a>         <span class="keyword">const</span> Operator2D&lt;T&gt; operator[]( <span class="keywordtype">int</span> x )<span class="keyword"> const </span>{ 
00281                 <span class="keywordflow">return</span> Operator2D&lt;T&gt;( <span class="keyword">this</span>, x ); }
00282 
00283 
00292         <span class="keyword">virtual</span> std::ostream&amp; put( std::ostream&amp; os, <span class="keyword">const</span> <span class="keywordtype">char</span> *format = NULL ) <span class="keyword">const</span>;
00293         
00294 
00298 <span class="comment">//      friend std::ostream&amp; operator&lt;&lt; ( std::ostream&amp; os, const RmMutableMatrix&lt;T&gt;&amp; v );</span>
00299 
00300 <span class="keyword">private</span>:
00301 
00302         <span class="keywordtype">int</span> m_initWidth, m_width;
00303         <span class="keywordtype">int</span> m_initHeight, m_height;
00304         T m_initVal;
00305         <span class="keyword">const</span> <span class="keywordtype">char</span>* m_colSep;
00306         <span class="keyword">const</span> <span class="keywordtype">char</span>* m_rowSep;
00307 
00308         std::vector&lt; std::vector&lt;T&gt; &gt; m_2dVector;
00309 
00310         <span class="keywordtype">bool</span> m_isAutoResizable;
00311 
00312 };
00313 
00314 
00315 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00316"></a><a class="code" href="class_rm_mutable_matrix.html#a9">00316</a> <a class="code" href="class_rm_mutable_matrix.html#a9">RmMutableMatrix&lt;T&gt;::RmMutableMatrix</a>( <span class="keywordtype">int</span> w , <span class="keywordtype">int</span> h, <span class="keyword">const</span> T initVal, <span class="keyword">const</span> <span class="keywordtype">char</span>* colSep, 
00317         <span class="keyword">const</span> <span class="keywordtype">char</span>* rowSep, <span class="keywordtype">bool</span> autoResize )
00318         : m_initWidth(w), m_width(w), m_initHeight(h), m_height(h),
00319           m_2dVector(h, std::vector&lt;T&gt;( w, initVal )), m_initVal(initVal),
00320           m_colSep(colSep), m_rowSep(rowSep), m_isAutoResizable(autoResize)
00321 {
00322 }
00323 
00324 
00325 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00326"></a><a class="code" href="class_rm_mutable_matrix.html#a4">00326</a> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a>&amp; <a class="code" href="class_rm_mutable_matrix.html#a4">RmMutableMatrix&lt;T&gt;::operator=</a>( <span class="keyword">const</span> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix</a>&amp; source )
00327 {
00328         m_initWidth = source.<a class="code" href="class_rm_mutable_matrix.html#r5">m_initWidth</a>;
00329         m_initHeight = source.<a class="code" href="class_rm_mutable_matrix.html#r3">m_initHeight</a>;
00330         m_initVal = source.<a class="code" href="class_rm_mutable_matrix.html#r4">m_initVal</a>;
00331         m_width = source.<a class="code" href="class_rm_mutable_matrix.html#r8">m_width</a>;
00332         m_height = source.<a class="code" href="class_rm_mutable_matrix.html#r2">m_height</a>;
00333         m_2dVector = source.<a class="code" href="class_rm_mutable_matrix.html#r0">m_2dVector</a>;
00334         m_isAutoResizable = source.<a class="code" href="class_rm_mutable_matrix.html#r6">m_isAutoResizable</a>;
00335         m_colSep = source.<a class="code" href="class_rm_mutable_matrix.html#r1">m_colSep</a>;
00336         m_rowSep = source.<a class="code" href="class_rm_mutable_matrix.html#r7">m_rowSep</a>;
00337 
00338         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00339 }
00340 
00341 
00342 
00343 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00344"></a><a class="code" href="class_rm_mutable_matrix.html#a8">00344</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( <span class="keywordtype">int</span> north, <span class="keywordtype">int</span> south, <span class="keywordtype">int</span> east, <span class="keywordtype">int</span> west )
00345 {
00346         <span class="comment">// A negative value removes that number of rows/colums from the corresponding border</span>
00347         <span class="comment">// A positive value adds that number of rows/colums to the corresponding border</span>
00348 
00349         <span class="keywordflow">if</span> ( m_height + north + south &lt; 0 || m_width + east + west &lt; 0 ) {
00350                 <span class="keywordtype">char</span> buff[100];
00351                 sprintf( buff, <span class="stringliteral">"height = %d, width = %d, north = %d, south = %d, east = %d, west = %d"</span>,
00352                         m_height, m_width, north, south, east, west );
00353                 assert( <span class="keyword">false</span> );
00354                 <span class="keywordflow">throw</span> <a class="code" href="struct_rm_exceptions_1_1_invalid_dimension_exception.html">RmExceptions::InvalidDimensionException</a>( <span class="stringliteral">"RmMutableMatrix&lt;T&gt;::resizeBy()"</span>, buff );
00355         }
00356 
00357         <span class="comment">// North</span>
00358         <span class="keywordflow">if</span> ( north &lt; 0 ) {
00359                 m_2dVector.erase( m_2dVector.begin(), m_2dVector.begin() + -north );
00360                 m_height += north;
00361         }
00362         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( north &gt; 0 ) {
00363                 m_2dVector.insert( m_2dVector.begin(), north, std::vector&lt;T&gt;( m_width, m_initVal ) );
00364                 m_height += north;
00365         }
00366 
00367         <span class="comment">// South</span>
00368         <span class="keywordflow">if</span> ( south &lt; 0 ) {
00369                 m_2dVector.erase( m_2dVector.end() + south, m_2dVector.end() );
00370                 m_height += south;
00371         }
00372         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( south &gt; 0 ) {
00373                 m_2dVector.insert( m_2dVector.end(), south, std::vector&lt;T&gt;( m_width, m_initVal ) );
00374                 m_height += south;
00375         }
00376 
00377         <span class="comment">// East</span>
00378         <span class="keywordflow">if</span> ( east &lt; 0 ) 
00379         {
00380                 <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::iterator rows = m_2dVector.begin(); 
00381                         rows != m_2dVector.end(); ++rows )
00382                 {
00383                         std::vector&lt;T&gt;&amp; row = *rows;
00384                         row.erase( row.end() + east, row.end() );
00385                 }
00386                 m_width += east;
00387         }
00388         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( east &gt; 0 ) {
00389                 <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::iterator rows = m_2dVector.begin(); 
00390                         rows != m_2dVector.end(); ++rows )
00391                 {
00392                         std::vector&lt;T&gt;&amp; row = *rows;
00393                         row.insert( row.end(), east, m_initVal );
00394                 }
00395                 m_width += east;
00396         }
00397 
00398         <span class="comment">// West</span>
00399         <span class="keywordflow">if</span> ( west &lt; 0 ) 
00400         {
00401                 <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::iterator rows = m_2dVector.begin(); 
00402                         rows != m_2dVector.end(); ++rows )
00403                 {
00404                         std::vector&lt;T&gt;&amp; row = *rows;
00405                         row.erase( row.begin(), row.begin() + -west );
00406                 }
00407                 m_width += west;
00408         }
00409         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( west &gt; 0 ) {
00410                 <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::iterator rows = m_2dVector.begin(); 
00411                         rows != m_2dVector.end(); ++rows )
00412                 {
00413                         std::vector&lt;T&gt;&amp; row = *rows;
00414                         row.insert( row.begin(), west, m_initVal );
00415                 }
00416                 m_width += west;
00417         }
00418 }
00419 
00420 
00421 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00422"></a><a class="code" href="class_rm_mutable_matrix.html#a0">00422</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_mutable_matrix.html#a0">RmMutableMatrix&lt;T&gt;::clear</a>()
00423 {
00424         <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::iterator rows = m_2dVector.begin(); 
00425                 rows != m_2dVector.end(); ++rows )
00426         {
00427                 <span class="keywordflow">for</span> ( std::vector&lt;T&gt;::iterator cols = (*rows).begin(); cols != (*rows).end(); ++cols )
00428                 {
00429                         *cols = m_initVal;
00430                 }
00431         }
00432 }
00433 
00434 
00435 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00436"></a><a class="code" href="class_rm_mutable_matrix.html#a1">00436</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_mutable_matrix.html#a1">RmMutableMatrix&lt;T&gt;::empty</a>()
00437 {
00438         <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( -(m_height - m_initHeight), 0, -(m_width - m_initWidth), 0 );
00439         <a class="code" href="class_rm_mutable_matrix.html#a0">RmMutableMatrix&lt;T&gt;::clear</a>();
00440 }
00441 
00442 
00443 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00444"></a><a class="code" href="class_rm_mutable_matrix.html#a14">00444</a> T&amp; <a class="code" href="class_rm_mutable_matrix.html#a14">RmMutableMatrix&lt;T&gt;::valueAt</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
00445 {
00446         <span class="comment">// This method is cannot be a const because out-of-bounds indexes cause</span>
00447         <span class="comment">// the matrix to be resized.</span>
00448 
00449         <span class="keywordflow">if</span> ( m_isAutoResizable ) 
00450         {
00451                 <span class="comment">// Grow height southward (positive) or northward (negative)</span>
00452                 <span class="keywordtype">int</span> yDelta = y &lt; 0 ? -y : y &gt;= m_height ? y - m_height + 1: 0;
00453                 <span class="keywordflow">if</span> ( yDelta != 0 ) {
00454                         <span class="keywordflow">if</span> ( y &gt;= 0 ) <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( 0, yDelta, 0, 0 );
00455                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( y &lt; 0 ) RmMutableMatrix&lt;T&gt;::resizeBy( yDelta, 0, 0, 0 );
00456                 }
00457 
00458                 <span class="comment">// Grow width eastward (positive) or westward (negative)</span>
00459                 <span class="keywordtype">int</span> xDelta = x &lt; 0 ? -x : x &gt;= m_width ? x - m_width + 1: 0;
00460                 <span class="keywordflow">if</span> ( xDelta != 0 ) {
00461                         <span class="keywordflow">if</span> ( x &gt;= 0 ) <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( 0, 0, xDelta, 0 );
00462                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( x &lt; 0 ) RmMutableMatrix&lt;T&gt;::resizeBy( 0, 0, 0, xDelta );
00463                 }
00464         }
00465         <span class="keywordflow">else</span>
00466         {
00467                 <span class="keywordflow">if</span> ( !(x &gt;= 0 &amp;&amp; x &lt; m_width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m_height) ) {
00468                         <span class="keywordtype">char</span> buff[50];
00469                         sprintf( buff, <span class="stringliteral">"Index constraint: [0..%d)[0..%d); Requested index: [%d][%d]"</span>, 
00470                                 m_width, m_height, x, y );
00471                         <span class="keywordflow">throw</span> <a class="code" href="struct_rm_exceptions_1_1_index_out_of_bounds_exception.html">RmExceptions::IndexOutOfBoundsException</a>( <span class="stringliteral">"RmMutableMatrix&lt;T&gt;::valueAt()"</span>, buff );
00472                 }
00473         }
00474 
00475         <span class="keywordflow">return</span> m_2dVector[y &lt; 0 ? 0 : y][x &lt; 0 ? 0 : x];
00476 }
00477 
00478 
00479 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00480"></a><a class="code" href="class_rm_mutable_matrix.html#a13">00480</a> <span class="keyword">const</span> T&amp; <a class="code" href="class_rm_mutable_matrix.html#a14">RmMutableMatrix&lt;T&gt;::valueAt</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )<span class="keyword"> const</span>
00481 <span class="keyword"></span>{
00482         <span class="keywordflow">if</span> ( !(x &gt;= 0 &amp;&amp; x &lt; m_width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m_height) ) {
00483                 <span class="keywordtype">char</span> buff[50];
00484                 sprintf( buff, <span class="stringliteral">"Index constraint: [0..%d)[0..%d); Requested index: [%d][%d]"</span>, 
00485                         m_width, m_height, x, y );
00486                 <span class="keywordflow">throw</span> <a class="code" href="struct_rm_exceptions_1_1_index_out_of_bounds_exception.html">RmExceptions::IndexOutOfBoundsException</a>( <span class="stringliteral">"RmMutableMatrix&lt;T&gt;::valueAt()"</span>, buff );
00487         }
00488 
00489         <span class="keywordflow">return</span> m_2dVector[y][x];
00490 }
00491 
00492 
00493 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00494"></a><a class="code" href="class_rm_mutable_matrix.html#a11">00494</a> <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a> <a class="code" href="class_rm_mutable_matrix.html#a11">RmMutableMatrix&lt;T&gt;::rotatedBy</a>( <span class="keyword">const</span> <span class="keywordtype">double</span> theta )<span class="keyword"> const</span>
00495 <span class="keyword"></span>{
00496         <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a> mm( *<span class="keyword">this</span> );
00497         mm.<a class="code" href="class_rm_mutable_matrix.html#a10">rotateBy</a>( theta );
00498         <span class="keywordflow">return</span> mm;
00499 }
00500 
00501 
00502 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00503"></a><a class="code" href="class_rm_mutable_matrix.html#a10">00503</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_mutable_matrix.html#a10">RmMutableMatrix&lt;T&gt;::rotateBy</a>( <span class="keyword">const</span> <span class="keywordtype">double</span> theta )
00504 {
00505         <span class="comment">// Adapted from:  </span>
00506         <span class="comment">// Robert D. Grappel, "Rotating a Weather Map"</span>
00507         <span class="comment">// Dr. Dobb's Journal, June 1999</span>
00508         <span class="comment">// http://www.ddj.com/documents/s=902/ddj9906h/9906h.htm (by subscription)</span>
00509         <span class="comment">// Requirements:  input/output matrices MUST BE SQUARE</span>
00510         <span class="comment">//</span>
00511         <span class="comment">// Adaptations:</span>
00512         <span class="comment">// - vectors, derived parameters, point-of-use initialization</span>
00513         <span class="comment">// - removal of negation on radian calculation</span>
00514         <span class="comment">// - boundaries on loops from [1..nij] to [0..nij)</span>
00515         <span class="comment">// - auto-sizing of matrix into square accommodating distance between opposite corners</span>
00516         <span class="comment">// - correction for 1-pixel drift</span>
00517 
00518         <span class="comment">// Create squared copy of this matrix as input matrix</span>
00519         <span class="keyword">const</span> <span class="keywordtype">int</span> w = m_width;
00520         <span class="keyword">const</span> <span class="keywordtype">int</span> h = m_height;
00521         <span class="keyword">const</span> <span class="keywordtype">int</span> d = static_cast&lt;int&gt;(sqrt( static_cast&lt;double&gt;(w * w + h * h) ) + 0.5);
00522         <span class="keyword">const</span> <span class="keywordtype">double</span> wDelta = (d - w) / 2.0;
00523         <span class="keyword">const</span> <span class="keywordtype">double</span> hDelta = (d - h) / 2.0;
00524         <a class="code" href="class_rm_mutable_matrix.html">RmMutableMatrix&lt;T&gt;</a> inmap( *<span class="keyword">this</span> );
00525         inmap.<a class="code" href="class_rm_mutable_matrix.html#a8">resizeBy</a>( hDelta, hDelta, wDelta, wDelta );
00526 
00527         <span class="comment">// Square and clear this matrix as the output matrix</span>
00528         <span class="keyword">const</span> <span class="keywordtype">int</span> nij = inmap.<a class="code" href="class_rm_mutable_matrix.html#r8">m_width</a>;
00529         <a class="code" href="class_rm_mutable_matrix.html#a0">RmMutableMatrix&lt;T&gt;::clear</a>();
00530         <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( hDelta, hDelta, wDelta, wDelta );
00531 
00532         <span class="comment">// Precalc optimizations</span>
00533         <span class="keyword">const</span> <span class="keywordtype">int</span> nijh = (nij / 2) + 1;            <span class="comment">/* midpoint of the map */</span>
00534         <span class="keywordtype">double</span> rad = theta * RmUtility::Pi / 180.0;          <span class="comment">/* convert angle to radians */</span>
00535         <span class="keyword">const</span> <span class="keywordtype">double</span> s = sin( rad );
00536         <span class="keyword">const</span> <span class="keywordtype">double</span> c = cos( rad );
00537         <span class="keyword">const</span> <span class="keywordtype">double</span> n0 = 0.5 - nijh;
00538 
00539         <span class="comment">/* precompute sine and cosine tables */</span>
00540         std::vector&lt;double&gt; s0( nij );
00541         std::vector&lt;double&gt; c0( nij );
00542         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; nij; i++ ) 
00543         { 
00544                 <span class="keyword">const</span> <span class="keywordtype">double</span> x0 = static_cast&lt;double&gt;(i) + n0;
00545                 c0[i] = x0 * c;  
00546                 s0[i] = x0 * s;
00547         }
00548 
00549         <span class="keywordflow">for</span> ( i = 0; i &lt; nij; i++ )
00550         {
00551                 <span class="keyword">const</span> <span class="keywordtype">double</span> cc0 = nijh + c0[i];  
00552                 <span class="keyword">const</span> <span class="keywordtype">double</span> ss0 = nijh - s0[i];
00553                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> j = 0; j &lt; nij; j++ )
00554                 {
00555                         <span class="keyword">const</span> <span class="keywordtype">double</span> x = cc0 + s0[j];
00556                         <span class="keywordflow">if</span> ((x &lt; 0) || (x &gt; nij)) <span class="keywordflow">continue</span>;
00557                         <span class="keyword">const</span> <span class="keywordtype">double</span> y = ss0 + c0[j];
00558                         <span class="keywordflow">if</span> ((y &lt; 0) || (y &gt; nij)) <span class="keywordflow">continue</span>;
00559                         <a class="code" href="class_rm_mutable_matrix.html#a14">RmMutableMatrix&lt;T&gt;::valueAt</a>( i, j ) = inmap.<a class="code" href="class_rm_mutable_matrix.html#a14">valueAt</a>( x, y );
00560                 }
00561         }
00562 
00564         <span class="comment">// Correct for drift</span>
00565 
00566         <span class="comment">// . . . . . . .  Position A is the actual center of the image before rotation</span>
00567         <span class="comment">// . . . . . . .  After rotation by theta, that cell drifts to one of B, C, or D, as follows:</span>
00568         <span class="comment">// . . . . . . .    [315..45) : position A (no drift)</span>
00569         <span class="comment">// . . . A B . .    [45..135) : position B</span>
00570         <span class="comment">// . . . D C . .    [135..225): position C</span>
00571         <span class="comment">// . . . . . . .    [225..315): position D</span>
00572         <span class="comment">// . . . . . . .</span>
00573 
00574         <span class="comment">// Shift theta 45 degrees clockwise so that A is [0..90), B is [90..180), etc.</span>
00575         <span class="comment">// And divide into one of four quadrants</span>
00576         <span class="keywordtype">int</span> q = theta + 45;
00577         <span class="keywordflow">if</span> ( q &gt;= 360 ) q -= 360;
00578         <span class="keywordflow">switch</span>( q /= 90 ) 
00579         {
00580                 <span class="keywordflow">case</span> 0: <span class="comment">// A</span>
00581                         <span class="keywordflow">break</span>;
00582                 <span class="keywordflow">case</span> 1: <span class="comment">// B</span>
00583                         <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( 0, 0, 1, -1 );
00584                         <span class="keywordflow">break</span>;
00585                 <span class="keywordflow">case</span> 2: <span class="comment">// C</span>
00586                         <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( -1, 1, 1, -1 );
00587                         <span class="keywordflow">break</span>;
00588                 <span class="keywordflow">case</span> 3: <span class="comment">// D</span>
00589                         <a class="code" href="class_rm_mutable_matrix.html#a8">RmMutableMatrix&lt;T&gt;::resizeBy</a>( -1, 1, 0, 0 );
00590                         <span class="keywordflow">break</span>;
00591         }
00592 }
00593 
00594 
00595 
00596 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00597"></a><a class="code" href="class_rm_mutable_matrix.html#a7">00597</a> std::ostream&amp; <a class="code" href="class_rm_mutable_matrix.html#a7">RmMutableMatrix&lt;T&gt;::put</a>( std::ostream&amp; os, <span class="keyword">const</span> <span class="keywordtype">char</span> *format )<span class="keyword"> const</span>
00598 <span class="keyword"></span>{
00599         <span class="keyword">static</span> <span class="keywordtype">char</span> buff[10]; <span class="comment">// temp 10 Feb 05</span>
00600 
00601         <span class="keywordflow">for</span> ( std::vector&lt; std::vector&lt;T&gt; &gt;::const_iterator rows = m_2dVector.begin(); 
00602                 rows != m_2dVector.end(); ++rows )
00603         {
00604                 <span class="keywordflow">for</span> ( std::vector&lt;T&gt;::const_iterator cols = rows-&gt;begin(); cols != rows-&gt;end(); ++cols )
00605                 {
00606                         <span class="keywordflow">if</span> ( format != NULL ) {
00607                                 sprintf( buff, format, *cols );
00608                                 os &lt;&lt; buff &lt;&lt; m_colSep; <span class="comment">// temp 10 Feb 05</span>
00609                         }
00610                         <span class="keywordflow">else</span> {
00611                                 os &lt;&lt; *cols &lt;&lt; m_colSep;
00612                         }
00613                 }
00614                 os &lt;&lt; m_rowSep;
00615         }
00616         <span class="keywordflow">return</span> os;
00617 }
00618 
00619 
00620 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00621 std::ostream&amp; operator&lt;&lt; ( std::ostream&amp; os, const RmMutableMatrix&lt;T&gt;&amp; v )
00622 {
00623         <span class="keywordflow">return</span> v.<a class="code" href="class_rm_mutable_matrix.html#a7">put</a>( os );
00624 }
00625 
00626 
00627 
00628 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Apr 3 16:46:53 2005 for Robot Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
