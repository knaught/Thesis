<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Robot Mapper: src/RmGlobalMap.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">src</a></div>
<h1>RmGlobalMap.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* </span>
00002 <span class="comment"> * RmGlobalMap.cpp</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Notes:</span>
00005 <span class="comment"> * On nomenclature.  Variables that have a world (unscaled) or grid (scaled) frame of reference are</span>
00006 <span class="comment"> * prepended with a "w" or "g", respectively.</span>
00007 <span class="comment"> */</span>
00008 
00009 <span class="preprocessor">#pragma warning( disable : 4786 )</span>
00010 <span class="preprocessor"></span>
00011 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00012 <span class="preprocessor">#include &lt;cmath&gt;</span>
00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
00014 <span class="preprocessor">#include &lt;string&gt;</span>
00015 <span class="preprocessor">#include "RmGlobalMap.h"</span>
00016 <span class="keyword">using</span> RmGlobalMap::RegionId;
00017 <span class="preprocessor">#include "RmUtilityExt.h"</span>
00018 <span class="preprocessor">#include "RmExceptions.h"</span>
00019 <span class="keyword">using</span> <span class="keyword">namespace </span>RmExceptions;
00020 <span class="preprocessor">#include "RmUtility.h"</span>
00021 
00022 
00023 <span class="keyword">using</span> <a class="code" href="struct_rm_utility_1_1_bound_box.html">RmUtility::BoundBox</a>;
00024 <span class="keyword">using</span> <a class="code" href="class_rm_utility_1_1_coord.html">RmUtility::Coord</a>;
00025 <span class="keyword">using</span> <a class="code" href="struct_rm_utility_1_1_pose.html">RmUtility::Pose</a>;
00026 <span class="keyword">using</span> <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">RmUtility::SonarReading</a>;
00027 <span class="keyword">using</span> <a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html">RmUtility::MappedSonarReading</a>;
00028 
00029 
<a name="l00030"></a><a class="code" href="class_rm_global_map.html#a9">00030</a> <a class="code" href="class_rm_global_map.html#a9">RmGlobalMap::RmGlobalMap</a>( <a class="code" href="struct_rm_settings.html">RmSettings</a>* s )
00031         : <a class="code" href="class_rm_bayes_certainty_grid.html">RmBayesCertaintyGrid</a>( s, <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>() ),
00032           m_settings(s), m_finalized(false), m_currentMap(NULL), m_wDistance(0.0), 
00033           m_regionMap(), m_maxRegionId(0)
00034 {
00035         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *signature_ = <span class="stringliteral">"RmGlobalMap::RmGlobalMap(RmSettings*)"</span>;
00036         <span class="keywordflow">if</span> ( s == NULL ) <span class="keywordflow">throw</span> <a class="code" href="struct_rm_exceptions_1_1_invalid_parameter_exception.html">InvalidParameterException</a>( signature_, <span class="stringliteral">"RmSettings may not be null"</span> );
00037 
00038         <span class="comment">// Open localization log file</span>
00039         <span class="keywordflow">if</span> ( s-&gt;<a class="code" href="struct_rm_settings.html#o7">Localize</a> &amp;&amp; s-&gt;<a class="code" href="struct_rm_settings.html#o4">GridName</a> != <span class="stringliteral">""</span> ) {
00040                 m_debugLogName = s-&gt;<a class="code" href="struct_rm_settings.html#o4">GridName</a>;
00041                 m_debugLogName.append( <span class="stringliteral">".log"</span> );
00042                 m_debugLog.open( m_debugLogName.c_str() );
00043                 m_debugLog.setf( std::ios_base::fixed, std::ios_base::floatfield );
00044                 m_debugLog.precision( 4 );
00045         }
00046 }
00047 
00048 
<a name="l00049"></a><a class="code" href="class_rm_global_map.html#b0">00049</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#b0">RmGlobalMap::addToRegionMap</a>( <a class="code" href="class_rm_local_map.html">RmLocalMap</a> *mt )
00050 {
00051 <span class="comment">//      m_maps.push_back( mt ); // TESTING TEMP (uncomment for direct call from main.cpp)</span>
00052 
00053         <span class="comment">// Integrates newly built independent L_t into G</span>
00054 
00055         <span class="comment">// Validate input</span>
00056         assert( mt != NULL );
00057         assert( mt-&gt;<a class="code" href="class_rm_local_map.html#a0">cumDistance</a>() &gt; 0 ); <span class="comment">// TESTING (comment out for direct call from main.cpp)</span>
00058         assert( m_maps.size() &gt; 0 );
00059 
00060         <span class="comment">// Init region boundary (rt) to that of the local map at time t (lt)</span>
00061         <span class="comment">// Note: map boundaries are expanded by one on their north and eastern borders so as to</span>
00062         <span class="comment">// compensate for the polygon filling routine which excludes cells along those borders</span>
00063         RmPolygon rt( mt-&gt;<a class="code" href="class_rm_bayes_certainty_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#a3">expandBy</a>( 1, 0, 1, 0 ) );
00064 <span class="comment">//      std::cout &lt;&lt; "Local map bound: " &lt;&lt; mt-&gt;bound() &lt;&lt; "\n";</span>
00065 <span class="comment">//      std::cout &lt;&lt; "Region bound: " &lt;&lt; rt &lt;&lt; "\n";</span>
00066 
00067         <span class="comment">// Init history of processed regions to region 0, that is, the non-region</span>
00068         std::set&lt;RegionId&gt; processedRegions;
00069         processedRegions.insert( 0 ); <span class="comment">// non-region has id of 0, which is treated as processed</span>
00070 
00071         <span class="comment">// For each prior local map (mi{i=t-1..0})</span>
00072         std::vector&lt;RmLocalMap*&gt;::reverse_iterator mip = m_maps.rbegin();
00073         <span class="keywordflow">while</span> ( ++mip != m_maps.rend() )
00074         {
00075                 <span class="comment">// If prior local map i (bi) intersects that at time t (bx)</span>
00076                 <span class="keyword">const</span> RmPolygon bi( (*mip)-&gt;bound().expandBy( 1, 0, 1, 0 ) );
00077                 <span class="keyword">const</span> RmPolygon bx( bi.intersectedWith( rt ) );
00078 <span class="comment">//              std::cout &lt;&lt; "rt:\n" &lt;&lt; rt &lt;&lt; "\nbi:\n" &lt;&lt; bi &lt;&lt; "\nbx:\n" &lt;&lt; bx &lt;&lt; "\n";</span>
00079                 <span class="keywordflow">if</span> ( bx.numContours() &gt; 0 ) 
00080                 {
00081                         <span class="comment">// For each cell in global map (G) over intersection (bx)</span>
00082                         std::vector&lt;Coord&gt; fill;
00083                         bx.fillInto( &amp;fill );
00084                         std::vector&lt;Coord&gt;::const_iterator cell;
00085                         <span class="keywordflow">for</span>( cell = fill.begin(); cell != fill.end(); ++cell )
00086                         {
00087                                 <span class="comment">// Get region assigned to that cell</span>
00088                                 <span class="keyword">const</span> <a class="code" href="class_rm_global_map.html#w0">RegionId</a> regionId = m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( cell-&gt;x, cell-&gt;y );
00089 
00090                                 <span class="comment">// If region not previously processed</span>
00091                                 <span class="keywordflow">if</span> ( processedRegions.count( regionId ) == 0 )
00092                                 {
00093                                         <span class="comment">// Get region's intersection (rx) with map bound intersection (bx)</span>
00094                                         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *rc = m_regions[regionId];
00095                                         <span class="comment">// ***</span>
00096                                         <span class="keyword">const</span> RmPolygon rx( rc-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o0">boundary</a>.intersectedWith( bx ) );
00097 <span class="comment">//                                      std::cout &lt;&lt; "rx:\n" &lt;&lt; rx &lt;&lt; "\n";</span>
00098 
00099                                         <span class="comment">// Subtract region intersection (rx) from bound of map at time t (rt)</span>
00100                                         rt -= rx;
00101 
00102                                         <span class="comment">// Subtract region intersection (rx) from region at current cell (rc)</span>
00103                                         RmPolygon bcx( rc-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o0">boundary</a> - rx );
00104 
00105                                         <span class="comment">// [Remove Rc-&gt;L that no longer intersect]</span>
00106 
00107                                         <span class="comment">// If region at cell (rc) is now empty, delete the region</span>
00108                                         <span class="comment">// Note: must use temp bcx so deleteRegion() has rc-&gt;boundary to work with</span>
00109                                         <span class="keywordflow">if</span> ( bcx.numContours() == 0 ) <a class="code" href="class_rm_global_map.html#b2">deleteRegion</a>( &amp;rc );
00110                                         <span class="keywordflow">else</span> rc-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o0">boundary</a> = bcx;
00111                                         
00112                                         <span class="comment">// Create new region (rnew) as intersection of cell region + map intersection</span>
00113                                         <span class="comment">// Fill new region (rnew) over global map (G) with Rnew.id</span>
00114                                         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *rnew = <a class="code" href="class_rm_global_map.html#b7">newRegion</a>( rx );
00115 
00116                                         <span class="comment">// Add map at time i (mi) and t (mt) to new region (rnew)</span>
00117                                         rnew-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.insert( *mip );
00118                                         rnew-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.insert( mt );
00119 
00120                                         <span class="comment">// Add maps from cell region (rc) that intersect new region (rnew)</span>
00121                                         <span class="keywordflow">if</span> ( rc != NULL ) { <span class="comment">// (if not just deleted)</span>
00122                                                 std::set&lt;RmLocalMap*&gt;::const_iterator mcp;                                      
00123                                                 <span class="keywordflow">for</span> ( mcp = rc-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.begin(); mcp != rc-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.end(); ++mcp ) 
00124                                                 {
00125                                                         <span class="comment">// Ignore those already assigned to the region</span>
00126                                                         <span class="keywordflow">if</span> ( *mcp == *mip || *mcp == mt ) <span class="keywordflow">continue</span>;
00127 
00128                                                         <span class="comment">// If intersects the region</span>
00129                                                         <span class="keywordflow">if</span> ( rx.intersectedWith( 
00130                                                                 RmPolygon( (*mcp)-&gt;bound() ) ).numContours() &gt; 0 ) 
00131                                                         {
00132                                                                 rnew-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.insert( *mcp );
00133                                                         }
00134                                                 }
00135                                         }
00136 
00137                                         <span class="comment">// Mark intersecting region as processed (original and new)</span>
00138                                         processedRegions.insert( regionId );
00139                                         processedRegions.insert( rnew-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o1">id</a> );
00140                                 }
00141                         }
00142                 }
00143         }
00144 
00145         
00146         <span class="comment">// If B not empty</span>
00147         <span class="keywordflow">if</span> ( rt.numContours() != 0 )
00148         {
00149                 <span class="comment">// Create new region R_t with boundary Bt</span>
00150                 <span class="comment">// For each G region cell in L_t, replace with R_new.id</span>
00151                 <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *rnew = <a class="code" href="class_rm_global_map.html#b7">newRegion</a>( rt );
00152 
00153                 <span class="comment">// Add L_t to R_new</span>
00154                 rnew-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.insert( mt );
00155         }
00156 }
00157 
00158 
<a name="l00159"></a><a class="code" href="class_rm_global_map.html#b1">00159</a> std::string <a class="code" href="class_rm_global_map.html#b1">RmGlobalMap::clearMapString</a>( <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_bound_box.html">BoundBox</a> &amp;gBound )<span class="keyword"> const</span>
00160 <span class="keyword"></span>{
00161         <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[(gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a> - gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a> + 1) * (gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a> - gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a> + 1) * 17 + 1];
00162         <span class="keywordtype">char</span> *buffPtr = &amp;buff[0];
00163 
00164         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; gY &gt;= gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --gY ) {
00165                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; gX &lt;= gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++gX ) {
00166                         sprintf( buffPtr, <span class="stringliteral">"%d %d %.4f;"</span>, gX, gY, RmBayesCertaintyGrid::InitVal );
00167                         buffPtr += strlen( buffPtr );
00168                 }
00169         }
00170 
00171         std::string logString( buff );
00172         <span class="keyword">delete</span>[] buff;
00173 
00174         <span class="keywordflow">return</span> logString;
00175 }
00176 
00177 
<a name="l00178"></a><a class="code" href="class_rm_global_map.html#a2">00178</a> <span class="keywordtype">float</span> <a class="code" href="class_rm_global_map.html#a2">RmGlobalMap::convolvedValueAt</a>( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )<span class="keyword"> const</span>
00179 <span class="keyword"></span>{
00180         <a class="code" href="class_rm_global_map.html#w0">RegionId</a> rId; <span class="comment">// region id</span>
00181 
00182         <span class="comment">// If the requested cell is out of bounds are not covered by a region,</span>
00183         <span class="comment">// return the default value</span>
00184         <span class="keywordflow">if</span> ( !<a class="code" href="class_rm_mutable_cartesian_grid.html#a4">inBounds</a>( <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>( x, y ) ) || (rId = m_regionMap[x][y]) == 0 ) {
00185                 <span class="keywordflow">return</span> RmBayesCertaintyGrid::InitVal;
00186         }
00187 
00188         <span class="comment">// Get the region covering the cell</span>
00189         std::map&lt;RegionId,Region*&gt;::const_iterator ri( m_regions.find( rId ) ); <span class="comment">// region iterator</span>
00190         assert( ri != m_regions.end() );
00191         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *r = (*ri).second;
00192 
00193         <span class="comment">// Sum non-empty probabilities for each local map assigned to the region</span>
00194         <span class="keywordtype">float</span> gPr = 0.0f; <span class="comment">// global map prior probability</span>
00195         <span class="keywordtype">int</span> cnt = 0;
00196         std::set&lt;RmLocalMap*&gt;::const_iterator mi; <span class="comment">// map iterator</span>
00197         <span class="keywordflow">for</span> ( mi = r-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.begin(); mi != r-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.end(); ++mi )
00198         {
00199                 <span class="comment">// Convolve values</span>
00200                 <span class="keywordtype">float</span> pr = (*mi)-&gt;valueAt( x, y );
00201                 <span class="keywordflow">if</span> ( pr != RmBayesCertaintyGrid::InitVal ) {
00202                         gPr += pr;
00203                         ++cnt;
00204                 }
00205         }
00206         gPr = cnt == 0 ? RmBayesCertaintyGrid::InitVal : gPr / cnt;
00207 
00208         <span class="keywordflow">return</span> gPr;
00209 }
00210 
00211 
<a name="l00212"></a><a class="code" href="class_rm_global_map.html#b2">00212</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#b2">RmGlobalMap::deleteRegion</a>( <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> **<span class="keyword">const</span> r )
00213 {
00214         assert( *r != NULL );
00215         assert( (*r)-&gt;id &gt; 0 );
00216 
00217         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *rorig = *r; <span class="comment">// save state so can assert it doesn't change</span>
00218 
00219         <a class="code" href="class_rm_global_map.html#b3">fillRegionMap</a>( *r, 0 );
00220         m_usedRegionIds.push( (*r)-&gt;id );
00221         m_regions.erase( (*r)-&gt;id );
00222 
00223         assert( rorig == *r ); <span class="comment">// this failed when calling this method from within an iteration</span>
00224                 <span class="comment">// over m_regions in RmGlobalMap::empty() because m_regions.erase() would delete *r first,</span>
00225                 <span class="comment">// and a second attempt below would cause a crash</span>
00226 
00227         <span class="keyword">delete</span> *r;
00228         *r = NULL;
00229 }
00230 
00231 
<a name="l00232"></a><a class="code" href="class_rm_global_map.html#a3">00232</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#a3">RmGlobalMap::empty</a>()
00233 {
00234         std::cout &lt;&lt; <span class="stringliteral">"RmGlobalMap::empty()\n"</span>;
00235 
00236         <span class="comment">// Free memory allocated for local maps</span>
00237         std::vector&lt;RmLocalMap*&gt;::const_iterator map;
00238         <span class="keywordflow">for</span> ( map = m_maps.begin(); map != m_maps.end(); ++map ) <span class="keyword">delete</span> *map;
00239         m_maps.clear();
00240 
00241         <span class="comment">// Free memory allocated for regions</span>
00242         std::map&lt;RegionId,Region*&gt;::const_iterator region;
00243         <span class="keywordflow">for</span> ( region = m_regions.begin(); region != m_regions.end(); ++region ) 
00244         {
00245                 <span class="keyword">const</span> <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *r = (*region).second;
00246                 <span class="keyword">delete</span> r;
00247                 r = NULL;
00248         }
00249         m_regions.clear(); <span class="comment">// empty collection of region pointers</span>
00250         m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a2">empty</a>(); <span class="comment">// empty the region grid</span>
00251         <span class="keywordflow">while</span> ( !m_usedRegionIds.empty() ) m_usedRegionIds.pop(); <span class="comment">// empty collection of used region ids</span>
00252         m_maxRegionId = 0; <span class="comment">// reset next region id</span>
00253 
00254         m_wDistance = 0.0;
00255         m_currentMap = NULL;
00256         m_gAccumShift = <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a>();
00257         m_finalized = <span class="keyword">false</span>;
00258         m_debugLog.seekp( 0 ); <span class="comment">// in lieu of closing and reopening, which doesn't work in dll mode</span>
00259 
00260         <a class="code" href="class_rm_mutable_cartesian_grid.html#a2">RmMutableCartesianGrid&lt;float&gt;::empty</a>();
00261 }
00262 
00263 
<a name="l00264"></a><a class="code" href="class_rm_global_map.html#b3">00264</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#b3">RmGlobalMap::fillRegionMap</a>( <span class="keyword">const</span> <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *<span class="keyword">const</span> r, <span class="keyword">const</span> RegionId <span class="keywordtype">id</span> )
00265 {
00266         assert( r != NULL );
00267         assert( <span class="keywordtype">id</span> &lt;= m_maxRegionId );
00268 
00269         std::vector&lt;Coord&gt; fill;
00270         r-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o0">boundary</a>.fillInto( &amp;fill );
00271         std::vector&lt;Coord&gt;::const_iterator cell;
00272         <span class="keywordflow">for</span>( cell = fill.begin(); cell != fill.end(); ++cell )
00273         {
00274                 <span class="comment">// Replace with R_new.id</span>
00275                 m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( cell-&gt;x, cell-&gt;y ) = id;
00276         }
00277 
00279         <span class="comment">// TEMP TESTING BLOCK</span>
00280 
00281 <span class="preprocessor">#if 0</span>
00282 <span class="preprocessor"></span>        m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a9">put</a>( std::cout, <span class="keyword">false</span>, <span class="stringliteral">"%02d"</span> );
00283         std::map&lt;RegionId,Region*&gt;::const_iterator ri;
00284         <span class="keywordflow">for</span> ( ri = m_regions.begin(); ri != m_regions.end(); ++ri )
00285         {
00286                 std::pair&lt;RegionId,Region*&gt; p = *ri;
00287                 <a class="code" href="class_rm_global_map.html#w0">RegionId</a> <span class="keywordtype">id</span> = p.first;
00288                 std::cout &lt;&lt; <span class="stringliteral">"Region "</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">": "</span>;
00289 
00290                 <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *region = p.second;
00291                 std::set&lt;RmLocalMap*&gt;::const_iterator m;
00292                 <span class="keywordflow">for</span> ( m = region-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.begin(); m != region-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.end(); ++m ) 
00293                 {
00294                         std::cout &lt;&lt; (*m)-&gt;pose() &lt;&lt; <span class="stringliteral">" "</span>;
00295                 }
00296 
00297                 std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;
00298         }
00299 
00300         std::cout &lt;&lt; <span class="stringliteral">"\n\n"</span>;
00301 <span class="preprocessor">#endif</span>
00302 <span class="preprocessor"></span>}
00303 
00304 
<a name="l00305"></a><a class="code" href="class_rm_global_map.html#a4">00305</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#a4">RmGlobalMap::finalize</a>()
00306 {
00307         <span class="keywordflow">if</span> ( m_finalized ) <span class="keywordflow">return</span>;
00308 
00309         <a class="code" href="class_rm_global_map.html#b0">addToRegionMap</a>( m_currentMap );
00310         <a class="code" href="class_rm_global_map.html#a6">integrate</a>();
00311 
00312         m_finalized = <span class="keyword">true</span>;
00313 }
00314 
00315 
<a name="l00316"></a><a class="code" href="class_rm_global_map.html#b4">00316</a> std::string <a class="code" href="class_rm_global_map.html#b4">RmGlobalMap::installNewMap</a>( <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a>&amp; wNewReading )
00317 {
00318         <span class="comment">// NOTE:  </span>
00319         <span class="comment">// In this context, the "current" map is the map just built in its entirety but not yet</span>
00320         <span class="comment">// convolved with the global map; the "new" map isn't created until after this current</span>
00321         <span class="comment">// map has been relocalized and convolved, and a new map pose localization accomplished</span>
00322         <span class="comment">// using newReading</span>
00323 
00324         <span class="comment">// Given three consecutive local maps, A, B, and C, with A being the first map built:</span>
00325         <span class="comment">// Pose A is neither localized prior to construction nor relocalized after construction</span>
00326         <span class="comment">//              because there is no current or prior map data to localize against</span>
00327         <span class="comment">// Pose B is localized prior to construction using map data from A, </span>
00328         <span class="comment">//              and relocalized after construction using its own data</span>
00329         <span class="comment">// Pose C is processed in like manner to B, but in reference to B, and so on</span>
00330 
00331         <span class="keyword">static</span> <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a> wCurrentReading_; <span class="comment">// saves reading used for current map's pose</span>
00332         std::string logString;
00333 
00334         <span class="keywordflow">if</span> ( m_currentMap != NULL )
00335         {
00336                 RmPolygon dirtyRegion( m_currentMap-&gt;<a class="code" href="class_rm_bayes_certainty_grid.html#a0">bound</a>() );
00337 
00339                 <span class="comment">// Relocalize map just finished building (at t-1)</span>
00340 
00341                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o7">Localize</a> &amp;&amp; m_maps.size() &gt; 1 ) 
00342                 {
00343                         <span class="comment">// NOTE: m_current map will be non-null and m_maps size will be == 1</span>
00344                         <span class="comment">// at the transition between maps A and B, as described above;</span>
00345                         <span class="comment">// The test for size &gt; 1 prevents a doomed attempt to relocalize map A</span>
00346 
00347                         <span class="comment">// Convolve local map into global map</span>
00348                         <a class="code" href="class_rm_global_map.html#b0">addToRegionMap</a>( m_currentMap );
00349 
00350                         <span class="comment">// Get updated relocalized pose for local map</span>
00351                         <a class="code" href="class_rm_local_map.html">RmLocalMap</a> &amp;priorMap = *m_maps[m_maps.size() - 2]; <span class="comment">// at transition between B and C, priorMap = A</span>
00352                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gLocPose = <a class="code" href="class_rm_global_map.html#b6">localizedPose</a>( priorMap, wCurrentReading_, m_debugLog );
00353                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gOldPose = m_currentMap-&gt;<a class="code" href="class_rm_local_map.html#a2">pose</a>().<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> );
00354                         gOldPose.<a class="code" href="struct_rm_utility_1_1_pose.html#o1">theta</a> = priorMap.<a class="code" href="class_rm_local_map.html#a2">pose</a>().<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a>.<a class="code" href="class_rm_utility_1_1_coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ).<a class="code" href="class_rm_utility_1_1_coord.html#a1">angleTo</a>( gOldPose.<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a> );
00355                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gPoseShift = gLocPose - gOldPose; <span class="comment">// scaled</span>
00356 
00357                         <span class="comment">// Restore global map to pre-convolved state</span>
00358                         <a class="code" href="class_rm_global_map.html#b8">removeFromRegionMap</a>( m_currentMap );
00359 
00360                         <span class="comment">// Shift local map by relocalized pose shift</span>
00361                         m_gAccumShift += gPoseShift;
00362                         m_currentMap-&gt;<a class="code" href="class_rm_local_map.html#a3">reorientBy</a>( gPoseShift.<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ) );
00363 
00364                         <span class="comment">// Expand dirty region to include shift</span>
00365                         dirtyRegion.unionWith( RmPolygon( m_currentMap-&gt;<a class="code" href="class_rm_bayes_certainty_grid.html#a0">bound</a>() ) );
00366 
00367                         <span class="keywordflow">if</span> ( m_debugLog ) m_debugLog &lt;&lt; <span class="stringliteral">"installNewMap() relocalize : "</span> &lt;&lt; gOldPose &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; gLocPose &lt;&lt; <span class="stringliteral">", "</span> 
00368                                 &lt;&lt; gPoseShift &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; m_gAccumShift &lt;&lt; std::endl;
00369                 }       
00370 
00371 
00373                 <span class="comment">// Convolve newly finished map with global map</span>
00374 
00375                 <span class="comment">// Add to region map</span>
00376                 <a class="code" href="class_rm_global_map.html#b0">addToRegionMap</a>( m_currentMap );
00377                 logString += <a class="code" href="class_rm_global_map.html#a6">integrate</a>( dirtyRegion, <span class="keyword">true</span> );
00378 
00379 
00381                 <span class="comment">// Localize new map based on map just finished</span>
00382 
00383                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o7">Localize</a> ) 
00384                 {
00385                         <span class="comment">// Find delta between selected pose of new and finished local map</span>
00386                         <span class="comment">// Shift local map pose by delta (heading?)</span>
00387                         <span class="comment">// calc angle between coords of current and new map</span>
00388 
00389                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gLocPose = <a class="code" href="class_rm_global_map.html#b6">localizedPose</a>( *m_currentMap, wNewReading, m_debugLog );
00390                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gPrePose( wNewReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a>.<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ) );
00391                         gPrePose.<a class="code" href="struct_rm_utility_1_1_pose.html#o1">theta</a> = m_currentMap-&gt;<a class="code" href="class_rm_local_map.html#a2">pose</a>().<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a>.<a class="code" href="class_rm_utility_1_1_coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ).<a class="code" href="class_rm_utility_1_1_coord.html#a1">angleTo</a>( gPrePose.coord );
00392                         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gPoseShift = gLocPose - gPrePose;
00393                         m_gAccumShift += gPoseShift;
00394 
00395                         <span class="keywordflow">if</span> ( m_debugLog ) m_debugLog &lt;&lt; <span class="stringliteral">"installNewMap() localize : "</span> &lt;&lt; gPrePose &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; gLocPose &lt;&lt; <span class="stringliteral">", "</span> 
00396                                 &lt;&lt; gPoseShift &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; m_gAccumShift &lt;&lt; std::endl;
00397                 }
00398         }
00399 
00400 
00402         <span class="comment">// Create new map, beginning with sonar data just used</span>
00403 
00404         wCurrentReading_ = wNewReading;
00405         wCurrentReading_.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a> = wNewReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a> + m_gAccumShift.<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> );
00406         m_maps.push_back( m_currentMap = <span class="keyword">new</span> <a class="code" href="class_rm_local_map.html">RmLocalMap</a>( m_settings, wCurrentReading_.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a> ) );
00407 
00408         <span class="keywordflow">return</span> logString;
00409 }
00410 
00411 
<a name="l00412"></a><a class="code" href="class_rm_global_map.html#a6">00412</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#a6">RmGlobalMap::integrate</a>()
00413 {
00414         <span class="comment">// For each cell in the region map (which represents the entire global map)</span>
00415         <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_bound_box.html">BoundBox</a> <a class="code" href="class_rm_global_map.html#a0">bound</a>( m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>() );
00416         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = <a class="code" href="class_rm_global_map.html#a0">bound</a>.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; y &gt;= <a class="code" href="class_rm_global_map.html#a0">bound</a>.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --y ) {
00417                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = <a class="code" href="class_rm_global_map.html#a0">bound</a>.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; x &lt;= <a class="code" href="class_rm_global_map.html#a0">bound</a>.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++x ) 
00418                 {
00419                         <span class="comment">// Store the convolved value of all local maps over the cell</span>
00420                         <span class="keyword">const</span> <a class="code" href="class_rm_global_map.html#w0">RegionId</a> rId = m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( x, y );
00421                         <a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( x, y ) = <a class="code" href="class_rm_global_map.html#a2">convolvedValueAt</a>( x, y );
00422                 }
00423         }
00424 }
00425 
00426 
00427 
<a name="l00428"></a><a class="code" href="class_rm_global_map.html#b5">00428</a> <span class="keyword">const</span> std::string <a class="code" href="class_rm_global_map.html#a6">RmGlobalMap::integrate</a>( <span class="keyword">const</span> RmPolygon &amp;bound, <span class="keywordtype">bool</span> retVal )
00429 {
00430         <span class="comment">// get cells filling region</span>
00431         std::vector&lt;Coord&gt; fill;
00432         bound.fillInto( &amp;fill );
00433 
00434         <span class="comment">// create update string buffer</span>
00435         <span class="comment">// format is "-xxx -yyy 0.dddd;"</span>
00436         <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[(fill.size() * 17 + 1) * <span class="keyword">sizeof</span>(char)];
00437         <span class="keywordtype">char</span> *buffPtr = buff;
00438         *buffPtr = <span class="charliteral">'\0'</span>;
00439 
00440         <span class="comment">// for each cell</span>
00441         std::vector&lt;Coord&gt;::const_iterator ci;
00442         <span class="keywordflow">for</span> ( ci = fill.begin(); ci != fill.end(); ++ci ) 
00443         {
00444                 <span class="keyword">const</span> <span class="keywordtype">float</span> pr = <a class="code" href="class_rm_global_map.html#a2">convolvedValueAt</a>( ci-&gt;x, ci-&gt;y );
00445                 <a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( ci-&gt;x, ci-&gt;y ) = pr;
00446                 
00447                 <span class="comment">// update log string by appending over previous terminating null</span>
00448                 <span class="keywordflow">if</span> ( retVal ) {
00449                         sprintf( buffPtr, <span class="stringliteral">"%d %d %.4f;"</span>, ci-&gt;x, ci-&gt;y, pr );
00450                         buffPtr += strlen( buffPtr );
00451                 }
00452         }
00453 
00454         <span class="comment">// tack on local map update string</span>
00455         std::string updateString( buff );
00456         <span class="keyword">delete</span>[] buff;
00457 
00458         <span class="keywordflow">return</span> updateString;
00459 }
00460 
00461 
00462 
00463 <span class="preprocessor">#undef _LOG</span>
00464 <span class="preprocessor"></span>
<a name="l00465"></a><a class="code" href="class_rm_global_map.html#b6">00465</a> <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> <a class="code" href="class_rm_global_map.html#b6">RmGlobalMap::localizedPose</a>( 
00466         <span class="keyword">const</span> <a class="code" href="class_rm_local_map.html">RmLocalMap</a> &amp;priorMap, <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a>&amp; wReading, std::ofstream&amp; log )<span class="keyword"> const</span>
00467 <span class="keyword"></span>{
00468         <span class="comment">// Note:  unscaled -&gt; in   out -&gt; scaled</span>
00469 
00470         <span class="keyword">static</span> <span class="keywordtype">int</span> cnt_ = 0;
00471         ++cnt_;
00472 <span class="preprocessor">        #ifdef _LOG</span>
00473 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"\n\nLOCAL MAP "</span> &lt;&lt; ((cnt_+1)/2) &lt;&lt; <span class="stringliteral">"\nDimension: "</span> &lt;&lt; priorMap.<a class="code" href="class_rm_bayes_certainty_grid.html#a8">width</a>() &lt;&lt; <span class="stringliteral">" x "</span> &lt;&lt; priorMap.<a class="code" href="class_rm_bayes_certainty_grid.html#a3">height</a>() &lt;&lt; <span class="stringliteral">"\n"</span>;
00474         log &lt;&lt; <span class="stringliteral">"SonarReading:\n"</span> &lt;&lt; wReading &lt;&lt; <span class="stringliteral">"\n"</span>;
00475 <span class="preprocessor">        #endif</span>
00476 <span class="preprocessor"></span>
00477         <span class="keyword">const</span> <a class="code" href="class_rm_bayes_sonar_model.html">RmBayesSonarModel</a> sonarModel( m_settings ); <span class="comment">// used to calc Pr(Occ)</span>
00478         <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gPose( wReading.robotPose.scaled( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ) );
00479 
00480         <span class="comment">// Calculate probability distribution of pose using motion model</span>
00481         <span class="comment">// Factors:  distance and degree of turns, where</span>
00482         <span class="comment">//    height increases proportionally to distance traveled</span>
00483         <span class="comment">//    width increases proportional to degrees turned</span>
00484         <span class="keyword">const</span> <span class="keywordtype">int</span> h = m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o2">MinHeight</a> + 
00485                 priorMap.<a class="code" href="class_rm_local_map.html#a0">cumDistance</a>() / m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o4">UnitDistance</a>;
00486         <span class="keyword">const</span> <span class="keywordtype">int</span> w = m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o3">MinWidth</a> + 
00487                 priorMap.<a class="code" href="class_rm_local_map.html#a1">cumTurn</a>() / m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o5">UnitTurn</a>;
00488         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseDist( RmUtility::gaussGrid( w, h, gPose.coord, gPose.theta, 
00489                 m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o1">GaussianSigma</a>, m_settings-&gt;<a class="code" href="struct_rm_settings.html#o13">MotionModel</a>.<a class="code" href="struct_rm_settings_1_1_motion_model_struct.html#o0">BendFactor</a> ) );
00490 
00491 <span class="preprocessor">        #ifdef _LOG</span>
00492 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"cumDistance("</span> &lt;&lt; priorMap.<a class="code" href="class_rm_local_map.html#a0">cumDistance</a>()
00493                 &lt;&lt; <span class="stringliteral">") cumTurn("</span> &lt;&lt; priorMap.<a class="code" href="class_rm_local_map.html#a1">cumTurn</a>() &lt;&lt; <span class="stringliteral">") gPoseDist["</span> &lt;&lt; w &lt;&lt; <span class="stringliteral">"]["</span> &lt;&lt; h &lt;&lt; <span class="stringliteral">"]\n"</span>;
00494 <span class="preprocessor">        #endif</span>
00495 <span class="preprocessor"></span>
00496         <span class="comment">//*** Debug</span>
00497         <span class="comment">// #ifndef _USRDLL</span>
00498 <span class="preprocessor">        #ifdef _LOG</span>
00499 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( log )
00500         {
00501                 <span class="keywordtype">char</span> *buff = <span class="keyword">new</span> <span class="keywordtype">char</span>[m_settings-&gt;<a class="code" href="struct_rm_settings.html#o4">GridName</a>.length() + 7];
00502 
00503                 <span class="comment">// Global map</span>
00504                 sprintf( buff, <span class="stringliteral">"%s%02d.gd"</span>, m_settings-&gt;<a class="code" href="struct_rm_settings.html#o4">GridName</a>.c_str(), cnt_ );
00505                 <span class="comment">//sprintf( buff, "%s.gd", m_settings-&gt;GridName.c_str() );</span>
00506                 <a class="code" href="class_rm_global_map.html#a6">integrate</a>();
00507                 <a class="code" href="class_rm_mutable_cartesian_grid.html#a9">RmMutableCartesianGrid&lt;float&gt;::put</a>( buff );
00508 
00509                 <span class="comment">// Global map with pose distributions</span>
00510                 <span class="keyword">static</span> std::vector&lt;RmMutableCartesianGrid&lt;float&gt; &gt; gPoseDists_;
00511                 gPoseDists.push_back( gPoseDist );
00512                 <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gpm( *<span class="keyword">this</span> );
00513                 std::vector&lt;RmMutableCartesianGrid&lt;float&gt; &gt;::const_iterator it;
00514                 <span class="keywordflow">for</span> ( it = gPoseDists_.begin(); it &lt; gPoseDists_.end(); ++it ) gpm.<a class="code" href="class_rm_mutable_cartesian_grid.html#a5">mergeWith</a>( *it );
00515                 sprintf( buff, <span class="stringliteral">"%s%02dp.gd"</span>, m_settings-&gt;<a class="code" href="struct_rm_settings.html#o4">GridName</a>.c_str(), cnt_ );
00516                 <span class="comment">//sprintf( buff, "%sp.gd", m_settings-&gt;GridName.c_str() );</span>
00517                 gpm.<a class="code" href="class_rm_mutable_cartesian_grid.html#a9">put</a>( buff );
00518 
00519                 <span class="keyword">delete</span>[] buff;
00520         }
00521 <span class="preprocessor">        #endif</span>
00522 <span class="preprocessor"></span>        <span class="comment">// #endif</span>
00523         <span class="comment">//*** End Debug</span>
00524         
00525         <span class="comment">// Histogram matrix over pose for tabulating selected poses for all sonars</span>
00526         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseHist( gPoseDist );
00527         gPoseHist.<a class="code" href="class_rm_mutable_matrix.html#a0">clear</a>();
00528         <span class="keywordtype">int</span> maxPoseHist = 0; <span class="comment">// highest value in histogram matrix</span>
00529         
00530         <span class="comment">// Create pose selection matrix, reinitialized for each sonar</span>
00531         <span class="comment">// Note: while gPoseSel is a histogrammic matrix, are using float rather than int because can't</span>
00532         <span class="comment">// easily copy configuration of gPoseDist any other way, and template class copy constructor</span>
00533         <span class="comment">// requires same type.</span>
00534         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseSel( gPoseDist ); <span class="comment">// convolves prOcc with gPoseDist</span>
00535 <span class="preprocessor">        #ifdef _LOG</span>
00536 <span class="preprocessor"></span>        <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseObs( gPoseDist ); <span class="comment">// tracks obstructions; log use only</span>
00537         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseGlo( gPoseDist ); <span class="comment">// global map about range reading; log use only</span>
00538         <a class="code" href="class_rm_mutable_cartesian_grid.html">RmMutableCartesianGrid&lt;float&gt;</a> gPoseOcc( gPoseDist ); <span class="comment">// occ grid about range reading; log use only</span>
00539         gPoseOcc.<a class="code" href="class_rm_mutable_matrix.html#a12">setInitValue</a>( 0.5f );
00540 <span class="preprocessor">        #endif</span>
00541 <span class="preprocessor"></span>
00542         <span class="comment">// For each sonar</span>
00543         <span class="keywordtype">bool</span> noneInRange = <span class="keyword">true</span>; <span class="comment">// indicates no sonar readings in range</span>
00544         <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a> wReadingCopy( wReading ); <span class="comment">// _UNSCALED_LOCALIZATION copy to be modified</span>
00545         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; RmPioneerController::NumSonars; ++i )
00546         {
00547                 <span class="comment">// Calc grid-based vector (direction and magnitude) for the range reading</span>
00548                 wReadingCopy.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o3">sonarNumber</a> = i;
00549                 wReadingCopy.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o1">distance</a> = wReadingCopy.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o0">all</a>[i];
00550                 <a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html">MappedSonarReading</a> &amp;gMR = 
00551                         <a class="code" href="class_rm_pioneer_controller.html#e1">RmPioneerController::rangeReading</a>( wReadingCopy ).<a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html#a1">scale</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> );
00552                         <span class="comment">// rangeReading() is best used with unscaled data</span>
00553 <span class="preprocessor">                #ifdef _LOG</span>
00554 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gMR;
00555 <span class="preprocessor">                #endif</span>
00556 <span class="preprocessor"></span>
00557                 <span class="comment">// Skip out-of-range readings</span>
00558                 <span class="comment">// (placed after calculation of mr so mr log entry can first be entered)</span>
00559                 <span class="keywordflow">if</span> ( wReadingCopy.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o1">distance</a> &gt; RmPioneerController::SonarRange ) {
00560 <span class="preprocessor">                        #ifdef _LOG</span>
00561 <span class="preprocessor"></span>                        log &lt;&lt; <span class="stringliteral">"Skipping out of range reading.\n"</span>;
00562 <span class="preprocessor">                        #endif</span>
00563 <span class="preprocessor"></span>                        <span class="keywordflow">continue</span>;
00564                 }
00565                 noneInRange = <span class="keyword">false</span>;
00566 
00567 
00568                 <span class="comment">// Init pose selection and log matrices</span>
00569                 gPoseSel.<a class="code" href="class_rm_mutable_matrix.html#a0">clear</a>();
00570 <span class="preprocessor">                #ifdef _LOG</span>
00571 <span class="preprocessor"></span>                gPoseObs.<a class="code" href="class_rm_mutable_matrix.html#a0">clear</a>();
00572                 gPoseOcc.<a class="code" href="class_rm_mutable_cartesian_grid.html#a14">setOrigin</a>( gMR.objectCoord );
00573                 gPoseOcc.<a class="code" href="class_rm_mutable_matrix.html#a0">clear</a>();
00574 <span class="preprocessor">                #endif</span>
00575 <span class="preprocessor"></span>
00576                 <span class="comment">// For each cell in pose distribution matrix</span>
00577                 <span class="keywordtype">float</span> maxPoseSel = 0.0; <span class="comment">// highest value in pose selection matrix</span>
00578                 <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_bound_box.html">BoundBox</a> gBound = gPoseDist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>();
00579                 <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gSonarShift = gMR.sonarPose.coord - gPose.coord;
00580                 <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gObjectShift = gMR.objectCoord - gMR.sonarPose.coord;
00581                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; gY &gt;= gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --gY ) {
00582                         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; gX &lt;= gBound.<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++gX ) 
00583                         {
00584                                 <span class="comment">// If cell at terminal end of range reading vector is unobstructed, </span>
00585                                 <span class="comment">// record pose selection likelihood</span>
00586                                 <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gStart = <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>( gX, gY ) + gSonarShift;
00587                                 <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gEnd = gStart + gObjectShift;
00588                                 <span class="keywordflow">if</span> ( !<a class="code" href="class_rm_global_map.html#a7">obstructionBetween</a>( gStart, gEnd ) ) 
00589                                 {
00590 <span class="preprocessor">                                        #ifdef _LOG</span>
00591 <span class="preprocessor"></span>                                        <span class="comment">// Record unostructed path for log output</span>
00592                                         gPoseObs[gX][gY] = 1.0f;
00593 <span class="preprocessor">                                        #endif</span>
00594 <span class="preprocessor"></span>
00595                                         <span class="comment">// get prior prob of occupied from global map</span>
00596                                         <span class="keyword">const</span> <span class="keywordtype">float</span> priorPrOcc = <a class="code" href="class_rm_global_map.html#a2">convolvedValueAt</a>( gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>, gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a> );
00597 
00598                                         <span class="comment">// get new prob of occupied for this pose dist cell</span>
00599                                         <span class="keyword">const</span> <span class="keywordtype">float</span> prOcc = sonarModel.<a class="code" href="class_rm_bayes_sonar_model.html#a0">prOccupiedGivenSn</a>( 
00600                                                 priorPrOcc, RmBayesSonarModel::RegionI, gMR.reading.distance );
00601 <span class="preprocessor">                                        #ifdef _LOG</span>
00602 <span class="preprocessor"></span>                                        gPoseOcc[gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>][gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>] = prOcc;
00603 <span class="preprocessor">                                        #endif</span>
00604 <span class="preprocessor"></span>
00605                                         <span class="keyword">const</span> <span class="keywordtype">float</span> s = gPoseSel[gX][gY] = prOcc * gPoseDist[gX][gY];
00606                                         
00607                                         <span class="keywordflow">if</span> ( s &gt; maxPoseSel ) maxPoseSel = s;
00608                                 }
00609                         }
00610                 }
00611 
00612                 <span class="comment">// Increment in pose histogram the cells corresponding to </span>
00613                 <span class="comment">// those in pose selection matrix with highest prob</span>
00614                 <span class="keywordflow">if</span> ( maxPoseSel &gt; 0 ) {
00615                         <span class="keywordflow">for</span> ( gY = gPoseSel.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; gY &gt;= gPoseSel.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --gY ) {
00616                                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gPoseSel.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; gX &lt;= gPoseSel.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++gX ) 
00617                                 {
00618                                         <span class="keywordflow">if</span> ( gPoseSel[gX][gY] == maxPoseSel ) {
00619                                                 <span class="keyword">const</span> <span class="keywordtype">int</span> h = ++gPoseHist[gX][gY]; <span class="comment">// store so don't have to call [][] twice</span>
00620                                                 <span class="keywordflow">if</span> ( h &gt; maxPoseHist ) maxPoseHist = h;
00621                                         }
00622                                 }
00623                         }
00624                 }
00625 
00626 <span class="preprocessor">                #ifdef _LOG</span>
00627 <span class="preprocessor"></span>                gPoseGlo.<a class="code" href="class_rm_mutable_cartesian_grid.html#a14">setOrigin</a>( gMR.objectCoord );
00628                 <a class="code" href="class_rm_mutable_cartesian_grid.html#a1">copyInto</a>( gPoseGlo );
00629                 log &lt;&lt; <span class="stringliteral">"PrOcc at object = "</span> &lt;&lt; gPoseOcc[gMR.objectCoord.x][gMR.objectCoord.y] &lt;&lt; <span class="stringliteral">", prior = "</span> &lt;&lt; gPoseGlo[gMR.objectCoord.x][gMR.objectCoord.y] &lt;&lt; <span class="stringliteral">"\n"</span>;
00630                 log &lt;&lt; <span class="stringliteral">"\nposeDistribution over Robot Pose, by local map, "</span> &lt;&lt; <span class="stringliteral">"Bound: "</span> &lt;&lt; gPoseDist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>() &lt;&lt; <span class="stringliteral">" Origin: "</span> 
00631                         &lt;&lt; gPoseDist.origin() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gPoseDist;
00632                 log &lt;&lt; <span class="stringliteral">"\nglobalMap over Object, by sonar, "</span> &lt;&lt; <span class="stringliteral">"Bound: "</span> &lt;&lt; gPoseGlo.bound() &lt;&lt; <span class="stringliteral">" Origin: "</span> 
00633                         &lt;&lt; gPoseGlo.origin() &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; gPoseGlo;
00634                 log &lt;&lt; <span class="stringliteral">"\nposeObstructions over Object, by sonar, 0 = obstructed (path from Robot Pose to Object)\n"</span> &lt;&lt; gPoseObs;
00635                 log &lt;&lt; <span class="stringliteral">"\nprOcc over Object, by unobstructed sonar\n"</span> &lt;&lt; gPoseOcc;
00636                 log &lt;&lt; <span class="stringliteral">"\nposeSelelections over Object, by sonar (gPoseDist * prOcc * gPoseObs)\n"</span> &lt;&lt; gPoseSel &lt;&lt; <span class="stringliteral">"\n"</span>;
00637                 log &lt;&lt; <span class="stringliteral">"poseHistogram over Robot Pose, by local map (max gPoseSel)\n"</span> &lt;&lt; gPoseHist &lt;&lt; <span class="stringliteral">"\n"</span>;
00638                 
00639                 log &lt;&lt; <span class="stringliteral">"===== End Sonar "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">"\n"</span>;
00640 <span class="preprocessor">                #endif</span>
00641 <span class="preprocessor"></span>        }
00642 
00643         <span class="comment">// If no poses were selected, all sonar readings were out of range</span>
00644         <span class="comment">// Can only return original pose</span>
00645         <span class="keywordflow">if</span> ( maxPoseHist == 0 ) {
00646 <span class="preprocessor">                #ifdef _LOG</span>
00647 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"\nNo sonar readings in range!\n\n"</span>;
00648 <span class="preprocessor">                #endif</span>
00649 <span class="preprocessor"></span>                <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gLocPose( wReading.robotPose.scaled( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ) );
00650                 gLocPose.theta = priorMap.<a class="code" href="class_rm_local_map.html#a2">pose</a>().<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a>.<a class="code" href="class_rm_utility_1_1_coord.html#a1">angleTo</a>( wReading.robotPose.coord );
00651                 <span class="keywordflow">return</span> gLocPose;
00652         }
00653 
00654         <span class="comment">// Get poses with max pose histogram value and record corresponding max post dist value</span>
00655         std::vector&lt;Coord&gt; gSelectedPoses;
00656         <span class="keywordtype">float</span> maxSelPoseDist = 0.0f;
00657         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gY = gPoseHist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; gY &gt;= gPoseHist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>; --gY ) {
00658                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> gX = gPoseHist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o1">ul</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; gX &lt;= gPoseHist.<a class="code" href="class_rm_mutable_cartesian_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#o0">lr</a>.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>; ++gX ) 
00659                 {
00660                         <span class="keywordflow">if</span> ( gPoseHist[gX][gY] == maxPoseHist ) {
00661                                 gSelectedPoses.push_back( <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>( gX, gY ) );
00662                                 <span class="keyword">const</span> <span class="keywordtype">float</span> pd = gPoseDist[gX][gY]; <span class="comment">// store so don't have to call [][] twice</span>
00663                                 <span class="keywordflow">if</span> ( pd &gt; maxSelPoseDist ) maxSelPoseDist = pd;
00664                         }
00665                 }
00666         }
00667 
00668         <span class="comment">// Filter all but those with the highest underlying maximum pose distribution</span>
00669         log &lt;&lt; <span class="stringliteral">"maxSelPoseDist = "</span> &lt;&lt; maxSelPoseDist &lt;&lt; <span class="stringliteral">"\n"</span>;
00670         std::vector&lt;Coord&gt;::iterator gSelectedPose = gSelectedPoses.begin();
00671         <span class="keywordflow">while</span> ( gSelectedPose &lt; gSelectedPoses.end() )
00672         {
00673                 <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gc( *gSelectedPose );
00674                 log &lt;&lt; gc &lt;&lt; <span class="stringliteral">":"</span> &lt;&lt; gPoseDist[gc.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>][gc.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>] &lt;&lt; <span class="stringliteral">" "</span>;
00675                 <span class="keywordflow">if</span> ( gPoseDist[gc.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>][gc.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a>] &lt; maxSelPoseDist ) {
00676                         gSelectedPoses.erase( gSelectedPose ); <span class="comment">// implicit ++gSelectedPose</span>
00677                         log &lt;&lt; <span class="stringliteral">"erased\n"</span>;
00678                 }
00679                 <span class="keywordflow">else</span> {
00680                         ++gSelectedPose;
00681                         log &lt;&lt; <span class="stringliteral">"retained\n"</span>;
00682                 }
00683         }
00684 
00685         <span class="comment">// If more than one selected pose, take the first (for now)</span>
00686         <span class="keywordflow">if</span> ( gSelectedPoses.size() != 1 ) 
00687         {
00688 <span class="preprocessor">                #ifdef _LOG</span>
00689 <span class="preprocessor"></span>                log &lt;&lt; <span class="stringliteral">"maxSelPoseDist = "</span> &lt;&lt; maxSelPoseDist &lt;&lt; <span class="stringliteral">"\n"</span>;
00690                 log &lt;&lt; <span class="stringliteral">"candidate poses: "</span>;
00691                 <span class="keywordflow">for</span> ( gSelectedPose = gSelectedPoses.begin(); gSelectedPose &lt; gSelectedPoses.end(); ++gSelectedPose )
00692                 {
00693                         log &lt;&lt; *gSelectedPose &lt;&lt; <span class="stringliteral">" "</span>;
00694                 }
00695                 log &lt;&lt; <span class="stringliteral">"\n"</span>;
00696 <span class="preprocessor">                #endif</span>
00697 <span class="preprocessor"></span>                <span class="keywordtype">char</span> buff[50];
00698                 sprintf( buff, <span class="stringliteral">"%d poses remain in filtered selection matrix"</span>, gSelectedPoses.size() );
00699                 <a class="code" href="struct_rm_exceptions_1_1_exception.html">RmExceptions::Exception</a> e( NULL, <span class="stringliteral">"RmGlobalMap::localizedPose()"</span>, buff );
00700 
00701                 <span class="comment">// This isn't an "error" so much as it is a condition;</span>
00702                 <span class="comment">// Notify and keep going</span>
00703                 std::cerr &lt;&lt; e;
00704 
00705                 <span class="comment">// Additional filters for narrowing down selections:</span>
00706                 <span class="comment">// - highest avg of surrounding cells, etc.</span>
00707                 <span class="comment">// - closes proximity to original pose</span>
00708         }
00709 
00710         <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> gSelCoord( gSelectedPoses.front() );
00711 
00712         <span class="comment">// Return the selected position and angle to that pos from current map's starting position</span>
00713         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gLocPose( gSelCoord, priorMap.<a class="code" href="class_rm_local_map.html#a2">pose</a>().<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a>.<a class="code" href="class_rm_utility_1_1_coord.html#a17">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ).<a class="code" href="class_rm_utility_1_1_coord.html#a1">angleTo</a>( gSelCoord ) );
00714 
00715 <span class="preprocessor">        #ifdef _LOG</span>
00716 <span class="preprocessor"></span>        log &lt;&lt; <span class="stringliteral">"selPose: "</span> &lt;&lt; gLocPose &lt;&lt; std::endl;
00717 <span class="preprocessor">        #endif</span>
00718 <span class="preprocessor"></span>
00719         <span class="keywordflow">return</span> gLocPose;
00720 }
00721 
00722 <span class="comment">/*</span>
00723 <span class="comment">void RmGlobalMap::moveOverRegionMap( const BoundBox &amp;from, const BoundBox &amp;to )</span>
00724 <span class="comment">{</span>
00725 <span class="comment">}</span>
00726 <span class="comment">*/</span>
00727 
00728 
<a name="l00729"></a><a class="code" href="class_rm_global_map.html#b7">00729</a> <a class="code" href="struct_rm_global_map_1_1_region.html">RmGlobalMap::Region</a>* <a class="code" href="class_rm_global_map.html#b7">RmGlobalMap::newRegion</a>( <span class="keyword">const</span> RmPolygon &amp;bound )
00730 {
00731         <a class="code" href="class_rm_global_map.html#w0">RegionId</a> id;
00732         <span class="keywordflow">if</span> ( m_usedRegionIds.empty() ) <span class="keywordtype">id</span> = ++m_maxRegionId;
00733         <span class="keywordflow">else</span> {
00734                 <span class="keywordtype">id</span> = m_usedRegionIds.front();
00735                 m_usedRegionIds.pop();
00736         }
00737 
00738         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *r = <span class="keyword">new</span> <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a>( <span class="keywordtype">id</span>, bound );
00739         m_regions[id] = r;
00740         
00741         <a class="code" href="class_rm_global_map.html#b3">fillRegionMap</a>( r, <span class="keywordtype">id</span> );
00742 
00743         <span class="keywordflow">return</span> r;
00744 }
00745 
00746 
<a name="l00747"></a><a class="code" href="class_rm_global_map.html#a7">00747</a> <span class="keywordtype">bool</span> <a class="code" href="class_rm_global_map.html#a7">RmGlobalMap::obstructionBetween</a>( <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>&amp; gStart, <span class="keyword">const</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a>&amp; gEnd )<span class="keyword"> const</span>
00748 <span class="keyword"></span>{
00749         <span class="comment">// Reasons for differences from original:</span>
00750         <span class="comment">// - Checking for obstruction to gcObject rather than f (in RmBayesCertaintyGrid obstruction check)</span>
00751         <span class="comment">// - Not processing last point in linePointList</span>
00752         <span class="comment">// - Checking global map</span>
00753 
00754         <span class="keywordtype">bool</span> obstructed = <span class="keyword">false</span>;
00755         <span class="keywordtype">float</span> prGlobal = 0.0f;
00756         <span class="keywordtype">float</span> prLocal = 0.0f;
00757         <span class="keyword">const</span> <span class="keywordtype">float</span> prObstr = m_settings-&gt;<a class="code" href="struct_rm_settings.html#o14">ObstructedCertainty</a>;
00758 
00759 <span class="preprocessor">#if 0  // on afit3, this is about 260ms slower than the else block (debug mode)</span>
00760 <span class="preprocessor"></span>        std::vector&lt;Coord&gt; line( RmPolygon::line( gStart, gEnd ) );
00761         std::vector&lt;Coord&gt;::const_iterator point;
00762         <span class="keywordflow">for</span> ( point = line.begin(); point != line.end(); ++point )
00763         {
00764                 <span class="keyword">const</span> <span class="keywordtype">int</span> gX = point-&gt;x;
00765                 <span class="keyword">const</span> <span class="keywordtype">int</span> gY = point-&gt;y;
00766 <span class="preprocessor">#else</span>
00767 <span class="preprocessor"></span>        <span class="keywordflow">for</span> ( PointList* gLinePointList = FillLine( gStart.x, gStart.y, gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o0">x</a>, gEnd.<a class="code" href="class_rm_utility_1_1_coord.html#o1">y</a> ); <span class="comment">// [start..end)</span>
00768                 gLinePointList; gLinePointList = gLinePointList-&gt;next )
00769         {
00770                 <span class="keyword">const</span> <span class="keywordtype">int</span> gX = gLinePointList-&gt;point.X;
00771                 <span class="keyword">const</span> <span class="keywordtype">int</span> gY = gLinePointList-&gt;point.Y;
00772 <span class="preprocessor">#endif</span>
00773 <span class="preprocessor"></span>                <span class="comment">// These tests short-circuit further testing of either local or global bounds </span>
00774                 <span class="comment">// once it has been determined one of them has been exceeded</span>
00775                 <span class="keywordtype">int</span> oneInBounds = 0;
00776                 <span class="keywordflow">if</span> ( prGlobal != -1.0f ) {
00777                         <span class="keywordflow">if</span> ( m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a4">inBounds</a>( gX, gY ) ) {
00778                                 prGlobal = <a class="code" href="class_rm_global_map.html#a2">convolvedValueAt</a>( gX, gY );
00779                                 ++oneInBounds;
00780                         }
00781                         <span class="keywordflow">else</span> prGlobal = -1.0f;
00782                 }
00783                 <span class="keywordflow">if</span> ( prLocal != -1.0f ) {
00784                         <span class="keywordflow">if</span> ( m_currentMap-&gt;<a class="code" href="class_rm_mutable_cartesian_grid.html#a4">inBounds</a>( gX, gY ) ) {
00785                                 prLocal = m_currentMap-&gt;<a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( gX, gY );
00786                                 ++oneInBounds;
00787                         }
00788                         <span class="keywordflow">else</span> prLocal = -1.0f;
00789                 }
00790 
00791                 <span class="comment">// This test short-circuits all future testing if neither one are in-bounds</span>
00792                 <span class="keywordflow">if</span> ( !oneInBounds ) 
00793                         <span class="keywordflow">break</span>;
00794 
00795                 <span class="keywordflow">if</span> ( prLocal &gt;= prObstr || prGlobal &gt;= prObstr )
00796                 {
00797                         obstructed = <span class="keyword">true</span>;
00798                         <span class="keywordflow">break</span>;
00799                 }
00800         }
00801 
00802         <span class="keywordflow">return</span> obstructed;
00803 }
00804 
00805 
<a name="l00806"></a><a class="code" href="class_rm_global_map.html#a8">00806</a> std::ostream&amp; <a class="code" href="class_rm_global_map.html#a8">RmGlobalMap::put</a>( std::ostream&amp; os )<span class="keyword"> const</span>
00807 <span class="keyword"></span>{ 
00808         m_settings-&gt;<a class="code" href="struct_rm_settings.html#a2">put</a>( os, <span class="stringliteral">"% "</span> );
00809 
00810 <span class="comment">//      RmGlobalMap map( m_settings );</span>
00811 <span class="comment">//      map.mergeWith( *this ); </span>
00812 <span class="comment">//      map.integrate( m_currentMap );</span>
00813 <span class="comment">//      return map.RmBayesCertaintyGrid::put( os ); </span>
00814 
00815         <span class="keywordflow">return</span> <a class="code" href="class_rm_bayes_certainty_grid.html#a4">RmBayesCertaintyGrid::put</a>( os );
00816 }
00817 
00818 
<a name="l00819"></a><a class="code" href="class_rm_global_map.html#b8">00819</a> <span class="keywordtype">void</span> <a class="code" href="class_rm_global_map.html#b8">RmGlobalMap::removeFromRegionMap</a>( <a class="code" href="class_rm_local_map.html">RmLocalMap</a> *map )
00820 {
00821         assert( map != NULL );
00822 
00823         <span class="comment">// Set up tracking of processed regions</span>
00824         std::set&lt;RegionId&gt; regionsProcessed;
00825         regionsProcessed.insert( 0 ); <span class="comment">// non-region has id of 0, which is treated as processed</span>
00826 
00827         <span class="comment">// For each cell within the map's bounds (with explicit inclusion of n/e borders)</span>
00828         RmPolygon bo( map-&gt;<a class="code" href="class_rm_bayes_certainty_grid.html#a0">bound</a>().<a class="code" href="struct_rm_utility_1_1_bound_box.html#a3">expandBy</a>( 1, 0, 1, 0 ) );
00829         std::vector&lt;Coord&gt; fill;
00830         bo.fillInto( &amp;fill );
00831         std::vector&lt;Coord&gt;::const_iterator ci;
00832         <span class="keywordflow">for</span> ( ci = fill.begin(); ci != fill.end(); ++ci ) 
00833         {
00834                 <span class="comment">// For regions not already processed</span>
00835                 <span class="keyword">const</span> <a class="code" href="class_rm_global_map.html#w0">RegionId</a> regionId = m_regionMap.<a class="code" href="class_rm_mutable_cartesian_grid.html#a18">valueAt</a>( ci-&gt;x, ci-&gt;y );
00836                 <span class="keywordflow">if</span> ( regionsProcessed.count( regionId ) == 0 ) 
00837                 {
00838                         <span class="comment">// Remove the map from the region</span>
00839                         <a class="code" href="struct_rm_global_map_1_1_region.html">Region</a> *r = m_regions[regionId];
00840                         r-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.erase( map );
00841 
00842                         <span class="comment">// If no maps cover the region any longer, delete it</span>
00843                         <span class="keywordflow">if</span> ( r-&gt;<a class="code" href="struct_rm_global_map_1_1_region.html#o2">maps</a>.size() == 0 ) <a class="code" href="class_rm_global_map.html#b2">deleteRegion</a>( &amp;r );
00844 
00845                         <span class="comment">// Mark region as processed</span>
00846                         regionsProcessed.insert( regionId );
00847                 }
00848         }
00849 }
00850 
00851 
<a name="l00852"></a><a class="code" href="class_rm_global_map.html#a10">00852</a> <span class="keyword">const</span> std::string <a class="code" href="class_rm_global_map.html#a10">RmGlobalMap::update</a>( <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a>&amp; wReading )
00853 {
00854         <span class="keywordflow">if</span> ( m_finalized ) <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00855 
00856         <span class="comment">// Accummulate distance traveled for current map</span>
00857         <span class="keyword">static</span> <span class="keywordtype">bool</span> newMap_ = <span class="keyword">true</span>;
00858         <span class="keyword">static</span> <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> wLastPos_;
00859         <a class="code" href="class_rm_utility_1_1_coord.html">Coord</a> wCurrPos = wReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a>.<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a>;
00860         <span class="keywordflow">if</span> ( !newMap_ ) m_wDistance += wLastPos_.<a class="code" href="class_rm_utility_1_1_coord.html#a3">distanceFrom</a>( wCurrPos );
00861         wLastPos_ = wCurrPos;
00862         newMap_ = <span class="keyword">false</span>;
00863 
00864         <span class="comment">// Initialize new map on first run</span>
00865         <span class="comment">// Would do in constructor but would have to assume origin pose of Pose()</span>
00866         std::string newMapString;
00867         <span class="keywordflow">if</span> ( m_currentMap == NULL )
00868         {
00869                 m_debugLog &lt;&lt; <span class="stringliteral">"Settings:\n"</span> &lt;&lt; *m_settings &lt;&lt; <span class="stringliteral">"\n"</span>;
00870                 newMapString = <a class="code" href="class_rm_global_map.html#b4">installNewMap</a>( wReading );
00871         }
00872 
00873         <span class="comment">// If total distance exceeds prescribed amount</span>
00874         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o8">LocalMapDistance</a> &gt; 0 &amp;&amp; m_wDistance &gt; m_settings-&gt;<a class="code" href="struct_rm_settings.html#o8">LocalMapDistance</a> )
00875         {
00876                 <span class="comment">// Create new map</span>
00877                 <span class="comment">// Add to map collection</span>
00878                 <span class="comment">// Set current local map to new map</span>
00879                 <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o7">Localize</a> ) newMapString = <a class="code" href="class_rm_global_map.html#b4">installNewMap</a>( wReading );
00880                 <span class="keywordflow">else</span> <a class="code" href="class_rm_global_map.html#b4">installNewMap</a>( wReading );
00881 
00882                 newMap_ = <span class="keyword">true</span>;
00883                 m_wDistance = 0.0;
00884         }
00885 
00886         <span class="comment">// Modify reading by pose shift updated in installNewMap()</span>
00887         <a class="code" href="struct_rm_utility_1_1_sonar_reading.html">SonarReading</a> wShiftedReading( wReading );
00888         wShiftedReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a> += m_gAccumShift.<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( 1.0 / m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> );
00889 
00890         <span class="comment">// Prepare default pose string</span>
00891         <a class="code" href="struct_rm_utility_1_1_pose.html">Pose</a> gRobotPose( wShiftedReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a>.<a class="code" href="struct_rm_utility_1_1_pose.html#a10">scaled</a>( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o2">CellSize</a> ) );
00892         <span class="keywordtype">char</span> logPose[30];
00893         sprintf( logPose, <span class="stringliteral">"%d %d %d %d %d\n"</span>, gRobotPose.coord.x, gRobotPose.coord.y, 
00894                 static_cast&lt;int&gt;(wReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o2">robotPose</a>.<a class="code" href="struct_rm_utility_1_1_pose.html#o1">theta</a>), wReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o3">sonarNumber</a>, wReading.<a class="code" href="struct_rm_utility_1_1_sonar_reading.html#o1">distance</a> );
00895 
00896 <span class="comment">/*      // Skip out of range and obstructed readings</span>
00897 <span class="comment">        // This is for cell and axis sonar models only:</span>
00898 <span class="comment">        // RmBayesCertaintyGrid processes out of range differently, and obstructions can't be tested</span>
00899 <span class="comment">        // because an entire cone would be considered an obstruction</span>
00900 <span class="comment">        const RmUtility::MappedSonarReading wMR = RmPioneerController::rangeReading( wShiftedReading );</span>
00901 <span class="comment">        if ( m_settings-&gt;IgnoreOutOfRange &amp;&amp; wReading.distance &gt; RmPioneerController::SonarRange ) { </span>
00902 <span class="comment">                return std::string( logPose );</span>
00903 <span class="comment">        }</span>
00904 <span class="comment">        if ( m_settings-&gt;IgnoreObstructed &amp;&amp; </span>
00905 <span class="comment">                obstructionBetween( gridCoord( wMR.sonarPose.coord ), gridCoord( wMR.objectCoord ) ) ) {</span>
00906 <span class="comment">                return "";</span>
00907 <span class="comment">        }</span>
00908 <span class="comment">*/</span>
00909 
00910         <span class="comment">// Skip obstructed readings (cell and axis models only)</span>
00911         <span class="keyword">const</span> <a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html">RmUtility::MappedSonarReading</a> wMR = <a class="code" href="class_rm_pioneer_controller.html#e1">RmPioneerController::rangeReading</a>( wShiftedReading );
00912         <span class="keywordflow">if</span> ( m_settings-&gt;<a class="code" href="struct_rm_settings.html#o19">SonarModel</a> != RmUtility::Cone &amp;&amp; m_settings-&gt;<a class="code" href="struct_rm_settings.html#o5">IgnoreObstructed</a> &amp;&amp; 
00913                 <a class="code" href="class_rm_global_map.html#a7">obstructionBetween</a>( <a class="code" href="class_rm_bayes_certainty_grid.html#b1">gridCoord</a>( wMR.<a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html#o2">sonarPose</a>.<a class="code" href="struct_rm_utility_1_1_pose.html#o0">coord</a> ), gridCoord( wMR.<a class="code" href="struct_rm_utility_1_1_mapped_sonar_reading.html#o0">objectCoord</a> ) ) ) {
00914                 <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00915         }
00916 
00917         <span class="comment">// Pass reading on to current local map</span>
00918         std::string logString = m_currentMap-&gt;<a class="code" href="class_rm_local_map.html#a7">update</a>( wMR );
00919 
00920         <span class="comment">// If update string is empty (due to out-of-range or disabled sonar)</span>
00921         <span class="comment">// but we have a new map update string, include log line 1 for return to viewer</span>
00922         <span class="keywordflow">if</span> ( logString.length() == 0 &amp;&amp; newMapString.length() &gt; 0 ) logString = logPose;
00923         <span class="keywordflow">else</span> logString = logString.substr( 0, logString.length() - 2 );
00924         logString += newMapString;
00925 
00926         <span class="keywordflow">return</span> logString;
00927 }
00928 
00929 
00930 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00931 std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v )
00932 {
00933         std::vector&lt;T&gt;::const_iterator it;
00934         <span class="keywordflow">for</span>( it = v.begin(); it != v.end(); ++it ) {
00935                 os &lt;&lt; *it &lt;&lt; <span class="stringliteral">" "</span>;
00936         }
00937         <span class="keywordflow">return</span> os;
00938 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Apr 3 16:46:53 2005 for Robot Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
