<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Robot Mapper: src/RmServer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">src</a></div>
<h1>RmServer.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">// RmServer.cpp</span>
00002 
00003 <span class="preprocessor">#include &lt;iostream&gt;</span>
00004 <span class="preprocessor">#include "RmServer.h"</span>
00005 <span class="preprocessor">#include "RmExceptions.h"</span>
00006 
00007 
<a name="l00008"></a><a class="code" href="classRmServer.html#a1">00008</a> <a class="code" href="classRmServer.html#a1">RmServer::RmServer</a>( <span class="keyword">const</span> <span class="keywordtype">short</span> portNumber, <span class="keyword">const</span> std::string name )
00009 : m_name(name)
00010 {
00011         WORD wVersionRequested = MAKEWORD(1,1);
00012         WSADATA wsaData;
00013     <span class="keywordtype">int</span> nRet = WSAStartup(wVersionRequested, &amp;wsaData);
00014         <span class="keywordflow">if</span> (wsaData.wVersion != wVersionRequested)
00015         {       
00016                 <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1SocketException.html">RmExceptions::SocketException</a>( <span class="stringliteral">"RmServer::RmServer()"</span>, <span class="stringliteral">"Wrong version"</span> );
00017         }
00018         
00019         <a class="code" href="classRmServer.html#b0">initServer</a>( portNumber );
00020 }
00021 
00022 
<a name="l00023"></a><a class="code" href="classRmServer.html#a3">00023</a> <a class="code" href="classRmServer.html#a3">RmServer::~RmServer</a>()
00024 {
00025         closesocket( m_socket );
00026 }
00027 
00028 
<a name="l00029"></a><a class="code" href="classRmServer.html#b0">00029</a> <span class="keywordtype">int</span> <a class="code" href="classRmServer.html#b0">RmServer::initServer</a>( <span class="keyword">const</span> <span class="keywordtype">short</span> portNumber )
00030 {
00031         <span class="keywordtype">int</span> nRet;
00032         <span class="keywordtype">char</span> temp[15] = <span class="stringliteral">""</span>;
00033         <span class="keywordtype">int</span> stopflag = 1;
00034         
00035         <span class="comment">//</span>
00036         <span class="comment">// Create a UDP/IP datagram socket</span>
00037         <span class="comment">//</span>
00038         m_socket = socket(AF_INET,              <span class="comment">// Address family</span>
00039                                            SOCK_DGRAM,  <span class="comment">// Socket type</span>
00040                                            IPPROTO_UDP);<span class="comment">// Protocol</span>
00041         <span class="keywordflow">if</span> (m_socket == INVALID_SOCKET)
00042         {
00043                 <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1SocketException.html">RmExceptions::SocketException</a>( <span class="stringliteral">"RmServer::initServer()"</span>, <span class="stringliteral">"Invalid socket"</span> );
00044         }
00045         
00046         
00047         <span class="comment">//</span>
00048         <span class="comment">// Fill in the address structure</span>
00049         <span class="comment">//</span>
00050         m_serverAddress.sin_family = AF_INET;
00051         m_serverAddress.sin_addr.s_addr = INADDR_ANY;           <span class="comment">// Let WinSock assign address</span>
00052         m_serverAddress.sin_port = htons(portNumber);           <span class="comment">// Use port passed from user</span>
00053         
00054         <span class="comment">//</span>
00055         <span class="comment">// Bind the server to the socket</span>
00056         <span class="comment">//</span>
00057         nRet = bind(m_socket, (LPSOCKADDR)&amp;m_serverAddress, <span class="keyword">sizeof</span>(SOCKADDR) );
00058         <span class="keywordflow">if</span> (nRet == SOCKET_ERROR)
00059         {
00060                 closesocket(m_socket);
00061                 <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1SocketException.html">RmExceptions::SocketException</a>( <span class="stringliteral">"RmServer::initServer()"</span>, <span class="stringliteral">"Unable to bind socket"</span> );
00062         }
00063         
00064         
00065         <span class="comment">//</span>
00066         <span class="comment">// Verify connection</span>
00067         <span class="comment">//</span>
00068         nRet = gethostname(m_szBuf, <span class="keyword">sizeof</span>(m_szBuf));
00069         <span class="keywordflow">if</span> (nRet == SOCKET_ERROR)
00070         {
00071                 closesocket(m_socket);
00072                 <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1SocketException.html">RmExceptions::SocketException</a>( <span class="stringliteral">"RmServer::initServer()"</span>, <span class="stringliteral">"Unable to get host name"</span> );
00073         }
00074         
00075         std::cout &lt;&lt; m_name &lt;&lt; <span class="stringliteral">" '"</span> &lt;&lt; m_szBuf &lt;&lt; <span class="stringliteral">"' waiting on port "</span> &lt;&lt; portNumber &lt;&lt; <span class="stringliteral">"\n"</span>;
00076         
00077         <span class="keywordflow">return</span> nRet;
00078 }
00079 
00080 
<a name="l00081"></a><a class="code" href="classRmServer.html#a0">00081</a> std::string <a class="code" href="classRmServer.html#a0">RmServer::getClientString</a>() 
00082 {
00083         <span class="keywordtype">int</span> nLen = <span class="keyword">sizeof</span>(SOCKADDR);
00084         memset( m_szBuf, 0, <span class="keyword">sizeof</span>(m_szBuf) );
00085         <span class="keywordtype">int</span> nRet = recvfrom( m_socket, m_szBuf, <span class="keyword">sizeof</span>(m_szBuf), 0, (LPSOCKADDR)&amp;m_clientAddress, &amp;nLen );
00086         <span class="keywordflow">return</span> std::string( m_szBuf );
00087 }
00088 
00089 
<a name="l00090"></a><a class="code" href="classRmServer.html#a2">00090</a> <span class="keywordtype">void</span> <a class="code" href="classRmServer.html#a2">RmServer::sendClientReply</a>( <span class="keyword">const</span> std::string s )
00091 {
00092         <span class="keywordtype">int</span> nRet = sendto( m_socket, s.c_str(), s.length(), 0, (LPSOCKADDR)&amp;m_clientAddress, 
00093                 <span class="keyword">sizeof</span>(SOCKADDR) );
00094         <span class="keywordflow">if</span> ( nRet == SOCKET_ERROR ) {
00095                 <span class="keyword">const</span> <span class="keywordtype">char</span> *m = <a class="code" href="classRmServer.html#b1">message</a>( <span class="stringliteral">"Socket error"</span> );
00096                 <span class="keywordflow">throw</span> <a class="code" href="structRmExceptions_1_1SocketException.html">RmExceptions::SocketException</a>( <span class="stringliteral">"RmServer::sendReply()"</span>, m );
00097         }
00098 }
00099 
<a name="l00100"></a><a class="code" href="classRmServer.html#b1">00100</a> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classRmServer.html#b1">RmServer::message</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> *msg )<span class="keyword"> const</span>
00101 <span class="keyword"></span>{
00102         <span class="keyword">static</span> <span class="keyword">const</span> std::string pre( <span class="stringliteral">" ["</span> );
00103         <span class="keyword">static</span> <span class="keyword">const</span> std::string suf( <span class="stringliteral">"]"</span> );
00104         std::string m = msg + pre + m_name + suf;
00105         <span class="keywordtype">char</span> *cmsg = <span class="keyword">new</span> <span class="keywordtype">char</span>[m.length() + 1];
00106         strcpy( cmsg, m.c_str() );
00107         <span class="keywordflow">return</span> cmsg;
00108 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 1 23:40:03 2005 for Robot Mapper by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
